diff -urN --exclude=.svn --exclude=.DS_Store --exclude='*.orig' --exclude='*.o' /tmp/lua-5.1.4/src/Makefile lua-5.1.4-patched/src/Makefile
--- /tmp/lua-5.1.4/src/Makefile	2008-01-19 21:37:58.000000000 +0200
+++ lua-5.1.4-patched/src/Makefile	2009-04-07 12:12:59.000000000 +0300
@@ -20,12 +20,12 @@
 
 # == END OF USER SETTINGS. NO NEED TO CHANGE ANYTHING BELOW THIS LINE =========
 
-PLATS= aix ansi bsd freebsd generic linux macosx mingw posix solaris
+PLATS= aix ansi bsd freebsd generic linux linux_sse macosx mingw posix solaris
 
 LUA_A=	liblua.a
 CORE_O=	lapi.o lcode.o ldebug.o ldo.o ldump.o lfunc.o lgc.o llex.o lmem.o \
 	lobject.o lopcodes.o lparser.o lstate.o lstring.o ltable.o ltm.o  \
-	lundump.o lvm.o lzio.o
+	lundump.o lvm.o lzio.o lnum.o
 LIB_O=	lauxlib.o lbaselib.o ldblib.o liolib.o lmathlib.o loslib.o ltablib.o \
 	lstrlib.o loadlib.o linit.o
 
@@ -98,6 +98,9 @@
 linux:
 	$(MAKE) all MYCFLAGS=-DLUA_USE_LINUX MYLIBS="-Wl,-E -ldl -lreadline -lhistory -lncurses"
 
+linux_sse:
+	$(MAKE) all MYCFLAGS="-DLUA_USE_LINUX -mfpmath=sse -msse2" MYLIBS="-Wl,-E -ldl -lreadline -lhistory -lncurses"
+
 macosx:
 	$(MAKE) all MYCFLAGS=-DLUA_USE_LINUX MYLIBS="-lreadline"
 # use this on Mac OS X 10.3-
@@ -120,63 +123,79 @@
 
 # DO NOT DELETE
 
-lapi.o: lapi.c lua.h luaconf.h lapi.h lobject.h llimits.h ldebug.h \
+lapi.o: lapi.c lua.h lapi.h lobject.h llimits.h ldebug.h \
   lstate.h ltm.h lzio.h lmem.h ldo.h lfunc.h lgc.h lstring.h ltable.h \
   lundump.h lvm.h
-lauxlib.o: lauxlib.c lua.h luaconf.h lauxlib.h
-lbaselib.o: lbaselib.c lua.h luaconf.h lauxlib.h lualib.h
-lcode.o: lcode.c lua.h luaconf.h lcode.h llex.h lobject.h llimits.h \
+lauxlib.o: lauxlib.c lua.h lauxlib.h
+lbaselib.o: lbaselib.c lua.h lauxlib.h lualib.h
+lcode.o: lcode.c lua.h lcode.h llex.h lobject.h llimits.h \
   lzio.h lmem.h lopcodes.h lparser.h ldebug.h lstate.h ltm.h ldo.h lgc.h \
   ltable.h
-ldblib.o: ldblib.c lua.h luaconf.h lauxlib.h lualib.h
-ldebug.o: ldebug.c lua.h luaconf.h lapi.h lobject.h llimits.h lcode.h \
+ldblib.o: ldblib.c lua.h lauxlib.h lualib.h
+ldebug.o: ldebug.c lua.h lapi.h lobject.h llimits.h lcode.h \
   llex.h lzio.h lmem.h lopcodes.h lparser.h ldebug.h lstate.h ltm.h ldo.h \
   lfunc.h lstring.h lgc.h ltable.h lvm.h
-ldo.o: ldo.c lua.h luaconf.h ldebug.h lstate.h lobject.h llimits.h ltm.h \
+ldo.o: ldo.c lua.h ldebug.h lstate.h lobject.h llimits.h ltm.h \
   lzio.h lmem.h ldo.h lfunc.h lgc.h lopcodes.h lparser.h lstring.h \
   ltable.h lundump.h lvm.h
-ldump.o: ldump.c lua.h luaconf.h lobject.h llimits.h lstate.h ltm.h \
+ldump.o: ldump.c lua.h lobject.h llimits.h lstate.h ltm.h \
   lzio.h lmem.h lundump.h
-lfunc.o: lfunc.c lua.h luaconf.h lfunc.h lobject.h llimits.h lgc.h lmem.h \
+lfunc.o: lfunc.c lua.h lfunc.h lobject.h llimits.h lgc.h lmem.h \
   lstate.h ltm.h lzio.h
-lgc.o: lgc.c lua.h luaconf.h ldebug.h lstate.h lobject.h llimits.h ltm.h \
+lgc.o: lgc.c lua.h ldebug.h lstate.h lobject.h llimits.h ltm.h \
   lzio.h lmem.h ldo.h lfunc.h lgc.h lstring.h ltable.h
-linit.o: linit.c lua.h luaconf.h lualib.h lauxlib.h
-liolib.o: liolib.c lua.h luaconf.h lauxlib.h lualib.h
-llex.o: llex.c lua.h luaconf.h ldo.h lobject.h llimits.h lstate.h ltm.h \
+linit.o: linit.c lua.h lualib.h lauxlib.h
+liolib.o: liolib.c lua.h lauxlib.h lualib.h
+llex.o: llex.c lua.h ldo.h lobject.h llimits.h lstate.h ltm.h \
   lzio.h lmem.h llex.h lparser.h lstring.h lgc.h ltable.h
-lmathlib.o: lmathlib.c lua.h luaconf.h lauxlib.h lualib.h
-lmem.o: lmem.c lua.h luaconf.h ldebug.h lstate.h lobject.h llimits.h \
+lmathlib.o: lmathlib.c lua.h lauxlib.h lualib.h
+lmem.o: lmem.c lua.h ldebug.h lstate.h lobject.h llimits.h \
   ltm.h lzio.h lmem.h ldo.h
-loadlib.o: loadlib.c lua.h luaconf.h lauxlib.h lualib.h
-lobject.o: lobject.c lua.h luaconf.h ldo.h lobject.h llimits.h lstate.h \
+lnum.o: lnum.c lua.h llex.h lnum.h
+loadlib.o: loadlib.c lua.h lauxlib.h lualib.h
+lobject.o: lobject.c lua.h ldo.h lobject.h llimits.h lstate.h \
   ltm.h lzio.h lmem.h lstring.h lgc.h lvm.h
-lopcodes.o: lopcodes.c lopcodes.h llimits.h lua.h luaconf.h
-loslib.o: loslib.c lua.h luaconf.h lauxlib.h lualib.h
-lparser.o: lparser.c lua.h luaconf.h lcode.h llex.h lobject.h llimits.h \
+lopcodes.o: lopcodes.c lopcodes.h llimits.h lua.h
+loslib.o: loslib.c lua.h lauxlib.h lualib.h
+lparser.o: lparser.c lua.h lcode.h llex.h lobject.h llimits.h \
   lzio.h lmem.h lopcodes.h lparser.h ldebug.h lstate.h ltm.h ldo.h \
   lfunc.h lstring.h lgc.h ltable.h
-lstate.o: lstate.c lua.h luaconf.h ldebug.h lstate.h lobject.h llimits.h \
+lstate.o: lstate.c lua.h ldebug.h lstate.h lobject.h llimits.h \
   ltm.h lzio.h lmem.h ldo.h lfunc.h lgc.h llex.h lstring.h ltable.h
-lstring.o: lstring.c lua.h luaconf.h lmem.h llimits.h lobject.h lstate.h \
+lstring.o: lstring.c lua.h lmem.h llimits.h lobject.h lstate.h \
   ltm.h lzio.h lstring.h lgc.h
-lstrlib.o: lstrlib.c lua.h luaconf.h lauxlib.h lualib.h
-ltable.o: ltable.c lua.h luaconf.h ldebug.h lstate.h lobject.h llimits.h \
+lstrlib.o: lstrlib.c lua.h lauxlib.h lualib.h
+ltable.o: ltable.c lua.h ldebug.h lstate.h lobject.h llimits.h \
   ltm.h lzio.h lmem.h ldo.h lgc.h ltable.h
-ltablib.o: ltablib.c lua.h luaconf.h lauxlib.h lualib.h
-ltm.o: ltm.c lua.h luaconf.h lobject.h llimits.h lstate.h ltm.h lzio.h \
+ltablib.o: ltablib.c lua.h lauxlib.h lualib.h
+ltm.o: ltm.c lua.h lobject.h llimits.h lstate.h ltm.h lzio.h \
   lmem.h lstring.h lgc.h ltable.h
-lua.o: lua.c lua.h luaconf.h lauxlib.h lualib.h
-luac.o: luac.c lua.h luaconf.h lauxlib.h ldo.h lobject.h llimits.h \
+lua.o: lua.c lua.h lauxlib.h lualib.h
+luac.o: luac.c lua.h lauxlib.h ldo.h lobject.h llimits.h \
   lstate.h ltm.h lzio.h lmem.h lfunc.h lopcodes.h lstring.h lgc.h \
   lundump.h
-lundump.o: lundump.c lua.h luaconf.h ldebug.h lstate.h lobject.h \
+lundump.o: lundump.c lua.h ldebug.h lstate.h lobject.h \
   llimits.h ltm.h lzio.h lmem.h ldo.h lfunc.h lstring.h lgc.h lundump.h
-lvm.o: lvm.c lua.h luaconf.h ldebug.h lstate.h lobject.h llimits.h ltm.h \
+lvm.o: lvm.c lua.h ldebug.h lstate.h lobject.h llimits.h ltm.h \
   lzio.h lmem.h ldo.h lfunc.h lgc.h lopcodes.h lstring.h ltable.h lvm.h
-lzio.o: lzio.c lua.h luaconf.h llimits.h lmem.h lstate.h lobject.h ltm.h \
+lzio.o: lzio.c lua.h llimits.h lmem.h lstate.h lobject.h ltm.h \
   lzio.h
-print.o: print.c ldebug.h lstate.h lua.h luaconf.h lobject.h llimits.h \
+print.o: print.c ldebug.h lstate.h lua.h lobject.h llimits.h \
   ltm.h lzio.h lmem.h lopcodes.h lundump.h
 
+lua.h: luaconf.h luaconf_internal.h
+
+lapi.c: lnum.h
+lauxlib.c: llimits.h
+lbaselib.c: llimits.h lobject.h lapi.h
+lcode.c: lnum.h
+liolib.c: lnum.h llex.h
+llex.c: lnum.h
+lnum.h: lobject.h
+lobject.c: llex.h lnum.h
+ltable.c: lnum.h
+lua.c: llimits.h
+lvm.c: llex.h lnum.h
+print.c: lnum.h
+
 # (end of Makefile)
diff -urN --exclude=.svn --exclude=.DS_Store --exclude='*.orig' --exclude='*.o' /tmp/lua-5.1.4/src/lapi.c lua-5.1.4-patched/src/lapi.c
--- /tmp/lua-5.1.4/src/lapi.c	2008-07-04 21:41:18.000000000 +0300
+++ lua-5.1.4-patched/src/lapi.c	2009-04-17 15:48:52.000000000 +0300
@@ -28,7 +28,7 @@
 #include "ltm.h"
 #include "lundump.h"
 #include "lvm.h"
-
+#include "lnum.h"
 
 
 const char lua_ident[] =
@@ -241,12 +241,15 @@
 
 LUA_API int lua_type (lua_State *L, int idx) {
   StkId o = index2adr(L, idx);
-  return (o == luaO_nilobject) ? LUA_TNONE : ttype(o);
+  return (o == luaO_nilobject) ? LUA_TNONE : ttype_ext(o);
 }
 
 
 LUA_API const char *lua_typename (lua_State *L, int t) {
   UNUSED(L);
+#ifdef LUA_TINT
+  lua_assert( t!= LUA_TINT );
+#endif
   return (t == LUA_TNONE) ? "no value" : luaT_typenames[t];
 }
 
@@ -264,6 +267,18 @@
 }
 
 
+LUA_API int lua_isinteger (lua_State *L, int idx) {
+  TValue tmp;
+  lua_Integer dum;
+  const TValue *o = index2adr(L, idx);
+#ifdef LUA_TINT
+  return tonumber(o,&tmp) && (ttisint(o) || tt_integer_valued(o,&dum));
+#else
+  return tonumber(o,&tmp) && tt_integer_valued(o,&dum);
+#endif
+}
+
+
 LUA_API int lua_isstring (lua_State *L, int idx) {
   int t = lua_type(L, idx);
   return (t == LUA_TSTRING || t == LUA_TNUMBER);
@@ -309,31 +324,67 @@
 }
 
 
-
 LUA_API lua_Number lua_tonumber (lua_State *L, int idx) {
   TValue n;
   const TValue *o = index2adr(L, idx);
-  if (tonumber(o, &n))
+  if (tonumber(o, &n)) {
+#ifdef LNUM_COMPLEX
+    if (nvalue_img(o) != 0)
+      luaG_runerror(L, "expecting a real number");
+#endif
     return nvalue(o);
-  else
-    return 0;
+  }
+  return 0;
 }
 
 
 LUA_API lua_Integer lua_tointeger (lua_State *L, int idx) {
   TValue n;
+    /* Lua 5.1 documented behaviour is to return nonzero for non-integer:
+     *
+     * "If the number is not an integer, it is truncated in some non-specified way." 
+     */
+#ifdef LUA_COMPAT_TOINTEGER
+  /* Lua 5.1 compatible */
   const TValue *o = index2adr(L, idx);
   if (tonumber(o, &n)) {
-    lua_Integer res;
-    lua_Number num = nvalue(o);
-    lua_number2integer(res, num);
-    return res;
+    lua_Integer i;
+    lua_Number d;
+# ifdef LUA_TINT
+    if (ttisint(o)) return ivalue(o);
+# endif
+# ifdef LNUM_COMPLEX
+    if (nvalue_img_fast(o) != 0)
+      luaG_runerror(L, "expecting a real number");
+# endif
+    d= nvalue_fast(o);
+    lua_number2integer(i, d);
+    return i;
   }
-  else
-    return 0;
+#else
+  /* New suggestion */
+  const TValue *o = index2adr(L, idx);
+  if (tonumber(o, &n)) {
+    lua_Integer i;
+    if (ttisint(o)) return ivalue(o);
+    if (tt_integer_valued(o,&i)) return i;
+  }
+#endif
+  return 0;
 }
 
 
+#ifdef LNUM_COMPLEX
+LUA_API lua_Complex lua_tocomplex (lua_State *L, int idx) {
+  TValue tmp;
+  const TValue *o = index2adr(L, idx);
+  if (tonumber(o, &tmp))
+    return nvalue_complex(o);
+  return 0;
+}
+#endif
+
+
 LUA_API int lua_toboolean (lua_State *L, int idx) {
   const TValue *o = index2adr(L, idx);
   return !l_isfalse(o);
@@ -364,6 +415,9 @@
     case LUA_TSTRING: return tsvalue(o)->len;
     case LUA_TUSERDATA: return uvalue(o)->len;
     case LUA_TTABLE: return luaH_getn(hvalue(o));
+#ifdef LUA_TINT
+    case LUA_TINT:
+#endif
     case LUA_TNUMBER: {
       size_t l;
       lua_lock(L);  /* `luaV_tostring' may create a new string */
@@ -426,6 +480,8 @@
 }
 
 
+/* 'lua_pushnumber()' may lose accuracy on integers, 'lua_pushinteger' will not.
+ */
 LUA_API void lua_pushnumber (lua_State *L, lua_Number n) {
   lua_lock(L);
   setnvalue(L->top, n);
@@ -434,12 +490,22 @@
 }
 
 
-LUA_API void lua_pushinteger (lua_State *L, lua_Integer n) {
+LUA_API void lua_pushinteger (lua_State *L, lua_Integer i) {
+  lua_lock(L);
+  setivalue(L->top, i);
+  api_incr_top(L);
+  lua_unlock(L);
+}
+
+
+#ifdef LNUM_COMPLEX
+LUA_API void lua_pushcomplex (lua_State *L, lua_Complex v) {
   lua_lock(L);
-  setnvalue(L->top, cast_num(n));
+  setnvalue_complex( L->top, v );
   api_incr_top(L);
   lua_unlock(L);
 }
+#endif
 
 
 LUA_API void lua_pushlstring (lua_State *L, const char *s, size_t len) {
@@ -569,7 +635,7 @@
   lua_lock(L);
   o = index2adr(L, idx);
   api_check(L, ttistable(o));
-  setobj2s(L, L->top, luaH_getnum(hvalue(o), n));
+  setobj2s(L, L->top, luaH_getint(hvalue(o), n));
   api_incr_top(L);
   lua_unlock(L);
 }
@@ -597,6 +663,11 @@
     case LUA_TUSERDATA:
       mt = uvalue(obj)->metatable;
       break;
+#ifdef LUA_TINT
+    case LUA_TINT:
+      mt = G(L)->mt[LUA_TNUMBER];
+      break;
+#endif
     default:
       mt = G(L)->mt[ttype(obj)];
       break;
@@ -687,7 +758,7 @@
   api_checknelems(L, 1);
   o = index2adr(L, idx);
   api_check(L, ttistable(o));
-  setobj2t(L, luaH_setnum(L, hvalue(o), n), L->top-1);
+  setobj2t(L, luaH_setint(L, hvalue(o), n), L->top-1);
   luaC_barriert(L, hvalue(o), L->top-1);
   L->top--;
   lua_unlock(L);
@@ -721,7 +792,7 @@
       break;
     }
     default: {
-      G(L)->mt[ttype(obj)] = mt;
+      G(L)->mt[ttype_ext(obj)] = mt;
       break;
     }
   }
@@ -1085,3 +1156,34 @@
   return name;
 }
 
+
+/* Help function for 'luaB_tonumber()', avoids multiple str->number
+ * conversions for Lua "tonumber()".
+ *
+ * Also pushes floating point numbers with integer value as integer, which
+ * can be used by 'tonumber()' in scripts to bring values back to integer
+ * realm.
+ *
+ * Note: The 'back to integer realm' is _not_ to affect string conversions:
+ * 'tonumber("4294967295.1")' should give a floating point value, although
+ * the value would be 4294967296 (and storable in int64 realm).
+ */
+#ifdef LUA_TINT
+int lua_pushvalue_as_number (lua_State *L, int idx)
+{
+  const TValue *o = index2adr(L, idx);
+  TValue tmp;
+  lua_Integer i;
+  if (ttisnumber(o)) {
+    if ( (!ttisint(o)) && tt_integer_valued(o,&i)) {
+      lua_pushinteger( L, i );
+      return 1;
+    }
+  } else if (!tonumber(o, &tmp)) {
+    return 0;
+  }
+  if (ttisint(o)) lua_pushinteger( L, ivalue(o) );
+  else lua_pushnumber( L, nvalue_fast(o) );
+  return 1;
+}
+#endif
diff -urN --exclude=.svn --exclude=.DS_Store --exclude='*.orig' --exclude='*.o' /tmp/lua-5.1.4/src/lapi.h lua-5.1.4-patched/src/lapi.h
--- /tmp/lua-5.1.4/src/lapi.h	2007-12-27 15:02:25.000000000 +0200
+++ lua-5.1.4-patched/src/lapi.h	2009-03-26 21:21:03.000000000 +0200
@@ -13,4 +13,8 @@
 
 LUAI_FUNC void luaA_pushobject (lua_State *L, const TValue *o);
 
+#ifdef LUA_TINT
+  int lua_pushvalue_as_number (lua_State *L, int idx);
+#endif
+
 #endif
diff -urN --exclude=.svn --exclude=.DS_Store --exclude='*.orig' --exclude='*.o' /tmp/lua-5.1.4/src/lauxlib.c lua-5.1.4-patched/src/lauxlib.c
--- /tmp/lua-5.1.4/src/lauxlib.c	2008-01-21 15:20:51.000000000 +0200
+++ lua-5.1.4-patched/src/lauxlib.c	2009-03-26 21:21:03.000000000 +0200
@@ -23,7 +23,7 @@
 #include "lua.h"
 
 #include "lauxlib.h"
-
+#include "llimits.h"
 
 #define FREELIST_REF	0	/* free list of references */
 
@@ -65,8 +65,8 @@
 }
 
 
-static void tag_error (lua_State *L, int narg, int tag) {
-  luaL_typerror(L, narg, lua_typename(L, tag));
+static void tag_error (lua_State *L, int narg, int t) {
+  luaL_typerror(L, narg, t<0 ? "integer" : lua_typename(L, t));
 }
 
 
@@ -188,8 +188,8 @@
 
 LUALIB_API lua_Integer luaL_checkinteger (lua_State *L, int narg) {
   lua_Integer d = lua_tointeger(L, narg);
-  if (d == 0 && !lua_isnumber(L, narg))  /* avoid extra test when d is not 0 */
-    tag_error(L, narg, LUA_TNUMBER);
+  if (d == 0 && !lua_isinteger(L, narg))  /* avoid extra test when d is not 0 */
+    tag_error(L, narg, -1 /*integer*/);
   return d;
 }
 
@@ -200,6 +200,16 @@
 }
 
 
+#ifdef LNUM_COMPLEX
+LUALIB_API lua_Complex luaL_checkcomplex (lua_State *L, int narg) {
+  lua_Complex c = lua_tocomplex(L, narg);
+  if (c == 0 && !lua_isnumber(L, narg))  /* avoid extra test when c is not 0 */
+    tag_error(L, narg, LUA_TNUMBER);
+  return c;
+}
+#endif
+
+
 LUALIB_API int luaL_getmetafield (lua_State *L, int obj, const char *event) {
   if (!lua_getmetatable(L, obj))  /* no metatable? */
     return 0;
diff -urN --exclude=.svn --exclude=.DS_Store --exclude='*.orig' --exclude='*.o' /tmp/lua-5.1.4/src/lauxlib.h lua-5.1.4-patched/src/lauxlib.h
--- /tmp/lua-5.1.4/src/lauxlib.h	2007-12-27 15:02:25.000000000 +0200
+++ lua-5.1.4-patched/src/lauxlib.h	2009-03-26 21:21:03.000000000 +0200
@@ -57,6 +57,12 @@
 LUALIB_API lua_Integer (luaL_checkinteger) (lua_State *L, int numArg);
 LUALIB_API lua_Integer (luaL_optinteger) (lua_State *L, int nArg,
                                           lua_Integer def);
+#define luaL_checkint32(L,narg) ((int)luaL_checkinteger(L,narg))
+#define luaL_optint32(L,narg,def) ((int)luaL_optinteger(L,narg,def))
+
+#ifdef LNUM_COMPLEX
+  LUALIB_API lua_Complex (luaL_checkcomplex) (lua_State *L, int narg);
+#endif
 
 LUALIB_API void (luaL_checkstack) (lua_State *L, int sz, const char *msg);
 LUALIB_API void (luaL_checktype) (lua_State *L, int narg, int t);
diff -urN --exclude=.svn --exclude=.DS_Store --exclude='*.orig' --exclude='*.o' /tmp/lua-5.1.4/src/lbaselib.c lua-5.1.4-patched/src/lbaselib.c
--- /tmp/lua-5.1.4/src/lbaselib.c	2008-02-14 18:46:22.000000000 +0200
+++ lua-5.1.4-patched/src/lbaselib.c	2009-03-26 21:21:03.000000000 +0200
@@ -18,7 +18,9 @@
 
 #include "lauxlib.h"
 #include "lualib.h"
-
+#include "llimits.h"
+#include "lobject.h"
+#include "lapi.h"
 
 
 
@@ -54,21 +56,30 @@
   int base = luaL_optint(L, 2, 10);
   if (base == 10) {  /* standard conversion */
     luaL_checkany(L, 1);
-    if (lua_isnumber(L, 1)) {
+    if (lua_isnumber(L, 1)) {       /* numeric string, or a number */
+#ifdef LUA_TINT
+      lua_pushvalue_as_number(L,1);     /* API extension (not to lose accuracy here) */
+#else
       lua_pushnumber(L, lua_tonumber(L, 1));
+#endif
       return 1;
-    }
+	}
   }
   else {
     const char *s1 = luaL_checkstring(L, 1);
     char *s2;
-    unsigned long n;
+    unsigned LUA_INTEGER n;
     luaL_argcheck(L, 2 <= base && base <= 36, 2, "base out of range");
-    n = strtoul(s1, &s2, base);
+    n = lua_str2ul(s1, &s2, base);
     if (s1 != s2) {  /* at least one valid digit? */
       while (isspace((unsigned char)(*s2))) s2++;  /* skip trailing spaces */
       if (*s2 == '\0') {  /* no invalid trailing characters? */
-        lua_pushnumber(L, (lua_Number)n);
+	  
+		/* Push as number, there needs to be separate 'luaB_tointeger' for
+		 * when the caller wants to preserve the bits (matters if unsigned
+		 * values are used).
+		 */
+        lua_pushnumber(L, cast_num(n));
         return 1;
       }
     }
@@ -144,7 +155,7 @@
   luaL_checktype(L, 2, LUA_TTABLE);
   getfunc(L, 0);
   lua_pushvalue(L, 2);
-  if (lua_isnumber(L, 1) && lua_tonumber(L, 1) == 0) {
+  if (lua_isnumber(L, 1) && lua_tointeger(L, 1) == 0) {
     /* change environment of current thread */
     lua_pushthread(L);
     lua_insert(L, -2);
@@ -201,7 +212,7 @@
   switch (optsnum[o]) {
     case LUA_GCCOUNT: {
       int b = lua_gc(L, LUA_GCCOUNTB, 0);
-      lua_pushnumber(L, res + ((lua_Number)b/1024));
+      lua_pushnumber(L, res + (cast_num(b)/1024));
       return 1;
     }
     case LUA_GCSTEP: {
@@ -209,7 +220,7 @@
       return 1;
     }
     default: {
-      lua_pushnumber(L, res);
+      lua_pushinteger(L, res);
       return 1;
     }
   }
@@ -631,6 +642,8 @@
   luaL_register(L, "_G", base_funcs);
   lua_pushliteral(L, LUA_VERSION);
   lua_setglobal(L, "_VERSION");  /* set global _VERSION */
+  lua_pushliteral(L, LUA_LNUM);
+  lua_setglobal(L, "_LNUM");  /* "[complex] double|float|ldouble [int16|int32|int64]" */
   /* `ipairs' and `pairs' need auxliliary functions as upvalues */
   auxopen(L, "ipairs", luaB_ipairs, ipairsaux);
   auxopen(L, "pairs", luaB_pairs, luaB_next);
diff -urN --exclude=.svn --exclude=.DS_Store --exclude='*.orig' --exclude='*.o' /tmp/lua-5.1.4/src/lcode.c lua-5.1.4-patched/src/lcode.c
--- /tmp/lua-5.1.4/src/lcode.c	2007-12-28 17:32:23.000000000 +0200
+++ lua-5.1.4-patched/src/lcode.c	2009-04-17 14:14:09.000000000 +0300
@@ -22,13 +22,18 @@
 #include "lopcodes.h"
 #include "lparser.h"
 #include "ltable.h"
+#include "lnum.h"
 
 
 #define hasjumps(e)	((e)->t != (e)->f)
 
-
 static int isnumeral(expdesc *e) {
-  return (e->k == VKNUM && e->t == NO_JUMP && e->f == NO_JUMP);
+  int ek=
+#ifdef LNUM_COMPLEX
+    (e->k == VKNUM2) ||
+#endif
+    (e->k == VKINT) || (e->k == VKNUM);
+  return (ek && e->t == NO_JUMP && e->f == NO_JUMP);
 }
 
 
@@ -229,14 +234,29 @@
 static int addk (FuncState *fs, TValue *k, TValue *v) {
   lua_State *L = fs->L;
   TValue *idx = luaH_set(L, fs->h, k);
-  Proto *f = fs->f;
-  int oldsize = f->sizek;
+#ifdef LUA_TINT
+  /* Note: Integer-valued LUA_TNUMBER's are handled as in unpatched Lua (below)
+  */
+  if (ttype(idx)==LUA_TINT) {
+# ifdef LNUM_INT64
+    lua_assert( (int)ivalue(idx) == ivalue(idx) );  /* make sure no data is lost in the casting */
+# endif
+    int i= (int)ivalue(idx);
+    lua_assert(luaO_rawequalObj(&fs->f->k[i], v));
+    return i;
+  }
+  else if (ttype(idx)==LUA_TNUMBER) {
+#else
   if (ttisnumber(idx)) {
-    lua_assert(luaO_rawequalObj(&fs->f->k[cast_int(nvalue(idx))], v));
-    return cast_int(nvalue(idx));
+#endif
+    int i= cast_int(nvalue_fast(idx));
+    lua_assert(luaO_rawequalObj(&fs->f->k[i], v));
+    return i;
   }
   else {  /* constant not found; create a new entry */
-    setnvalue(idx, cast_num(fs->nk));
+    Proto *f = fs->f;
+    int oldsize = f->sizek;
+    setivalue(idx, fs->nk);
     luaM_growvector(L, f->k, fs->nk, f->sizek, TValue,
                     MAXARG_Bx, "constant table overflow");
     while (oldsize < f->sizek) setnilvalue(&f->k[oldsize++]);
@@ -261,6 +281,21 @@
 }
 
 
+int luaK_integerK (FuncState *fs, lua_Integer r) {
+  TValue o;
+  setivalue(&o, r);
+  return addk(fs, &o, &o);
+}
+
+
+#ifdef LNUM_COMPLEX
+static int luaK_imagK (FuncState *fs, lua_Number r) {
+  TValue o;
+  setnvalue_complex(&o, r*I);
+  return addk(fs, &o, &o);
+}
+#endif
+
 static int boolK (FuncState *fs, int b) {
   TValue o;
   setbvalue(&o, b);
@@ -359,6 +394,16 @@
       luaK_codeABx(fs, OP_LOADK, reg, luaK_numberK(fs, e->u.nval));
       break;
     }
+    case VKINT: {
+      luaK_codeABx(fs, OP_LOADK, reg, luaK_integerK(fs, e->u.ival));
+      break;
+    }
+#ifdef LNUM_COMPLEX
+    case VKNUM2: {
+      luaK_codeABx(fs, OP_LOADK, reg, luaK_imagK(fs, e->u.nval));
+      break;
+    }
+#endif
     case VRELOCABLE: {
       Instruction *pc = &getcode(fs, e);
       SETARG_A(*pc, reg);
@@ -444,6 +489,10 @@
 int luaK_exp2RK (FuncState *fs, expdesc *e) {
   luaK_exp2val(fs, e);
   switch (e->k) {
+#ifdef LNUM_COMPLEX
+    case VKNUM2:
+#endif
+    case VKINT:
     case VKNUM:
     case VTRUE:
     case VFALSE:
@@ -451,6 +500,10 @@
       if (fs->nk <= MAXINDEXRK) {  /* constant fit in RK operand? */
         e->u.s.info = (e->k == VNIL)  ? nilK(fs) :
                       (e->k == VKNUM) ? luaK_numberK(fs, e->u.nval) :
+                      (e->k == VKINT) ? luaK_integerK(fs, e->u.ival) :
+#ifdef LNUM_COMPLEX
+                      (e->k == VKNUM2) ? luaK_imagK(fs, e->u.nval) :
+#endif
                                         boolK(fs, (e->k == VTRUE));
         e->k = VK;
         return RKASK(e->u.s.info);
@@ -540,7 +593,10 @@
   int pc;  /* pc of last jump */
   luaK_dischargevars(fs, e);
   switch (e->k) {
-    case VK: case VKNUM: case VTRUE: {
+#ifdef LNUM_COMPLEX
+    case VKNUM2:
+#endif
+    case VKINT: case VK: case VKNUM: case VTRUE: {
       pc = NO_JUMP;  /* always true; do nothing */
       break;
     }
@@ -598,7 +654,10 @@
       e->k = VTRUE;
       break;
     }
-    case VK: case VKNUM: case VTRUE: {
+#ifdef LNUM_COMPLEX
+    case VKNUM2:
+#endif
+    case VKINT: case VK: case VKNUM: case VTRUE: {
       e->k = VFALSE;
       break;
     }
@@ -634,25 +693,72 @@
 
 static int constfolding (OpCode op, expdesc *e1, expdesc *e2) {
   lua_Number v1, v2, r;
+  int vkres= VKNUM;
   if (!isnumeral(e1) || !isnumeral(e2)) return 0;
-  v1 = e1->u.nval;
-  v2 = e2->u.nval;
+
+  /* real and imaginary parts don't mix. */
+#ifdef LNUM_COMPLEX
+  if (e1->k == VKNUM2) {
+    if ((op != OP_UNM) && (e2->k != VKNUM2)) return 0; 
+    vkres= VKNUM2; }
+  else if (e2->k == VKNUM2) { return 0; }
+#endif
+#ifdef LUA_TINT
+  if ((e1->k == VKINT) && (e2->k == VKINT)) {
+    lua_Integer i1= e1->u.ival, i2= e2->u.ival;
+    lua_Integer rr;
+    int done= 0;
+    /* Integer/integer calculations (may end up producing floating point) */
+    switch (op) {
+      case OP_ADD: done= try_addint( &rr, i1, i2 ); break;
+      case OP_SUB: done= try_subint( &rr, i1, i2 ); break;
+      case OP_MUL: done= try_mulint( &rr, i1, i2 ); break;
+      case OP_DIV: done= try_divint( &rr, i1, i2 ); break;
+      case OP_MOD: done= try_modint( &rr, i1, i2 ); break;
+      case OP_POW: done= try_powint( &rr, i1, i2 ); break;
+      case OP_UNM: done= try_unmint( &rr, i1 ); break;
+      default:     done= 0; break;
+    }
+    if (done) {
+      e1->u.ival = rr;  /* remained within integer range */
+      return 1;
+    }
+  }
+#endif
+  v1 = (e1->k == VKINT) ? cast_num(e1->u.ival) : e1->u.nval;
+  v2 = (e2->k == VKINT) ? cast_num(e2->u.ival) : e2->u.nval;
+
   switch (op) {
     case OP_ADD: r = luai_numadd(v1, v2); break;
     case OP_SUB: r = luai_numsub(v1, v2); break;
-    case OP_MUL: r = luai_nummul(v1, v2); break;
+    case OP_MUL: 
+#ifdef LNUM_COMPLEX
+        if (vkres==VKNUM2) return 0;    /* leave to runtime (could do here, but not worth it?) */
+#endif
+        r = luai_nummul(v1, v2); break;
     case OP_DIV:
       if (v2 == 0) return 0;  /* do not attempt to divide by 0 */
-      r = luai_numdiv(v1, v2); break;
+#ifdef LNUM_COMPLEX
+        if (vkres==VKNUM2) return 0;    /* leave to runtime */
+#endif
+        r = luai_numdiv(v1, v2); break;
     case OP_MOD:
       if (v2 == 0) return 0;  /* do not attempt to divide by 0 */
+#ifdef LNUM_COMPLEX
+      if (vkres==VKNUM2) return 0;    /* leave to runtime */
+#endif
       r = luai_nummod(v1, v2); break;
-    case OP_POW: r = luai_numpow(v1, v2); break;
+    case OP_POW: 
+#ifdef LNUM_COMPLEX
+      if (vkres==VKNUM2) return 0;    /* leave to runtime */
+#endif
+      r = luai_numpow(v1, v2); break;
     case OP_UNM: r = luai_numunm(v1); break;
     case OP_LEN: return 0;  /* no constant folding for 'len' */
     default: lua_assert(0); r = 0; break;
   }
   if (luai_numisnan(r)) return 0;  /* do not attempt to produce NaN */
+  e1->k = cast(expkind,vkres);
   e1->u.nval = r;
   return 1;
 }
@@ -696,7 +802,8 @@
 
 void luaK_prefix (FuncState *fs, UnOpr op, expdesc *e) {
   expdesc e2;
-  e2.t = e2.f = NO_JUMP; e2.k = VKNUM; e2.u.nval = 0;
+  e2.t = e2.f = NO_JUMP; e2.k = VKINT; e2.u.ival = 0;
+
   switch (op) {
     case OPR_MINUS: {
       if (!isnumeral(e))
diff -urN --exclude=.svn --exclude=.DS_Store --exclude='*.orig' --exclude='*.o' /tmp/lua-5.1.4/src/lcode.h lua-5.1.4-patched/src/lcode.h
--- /tmp/lua-5.1.4/src/lcode.h	2007-12-27 15:02:25.000000000 +0200
+++ lua-5.1.4-patched/src/lcode.h	2009-03-26 21:21:04.000000000 +0200
@@ -71,6 +71,6 @@
 LUAI_FUNC void luaK_infix (FuncState *fs, BinOpr op, expdesc *v);
 LUAI_FUNC void luaK_posfix (FuncState *fs, BinOpr op, expdesc *v1, expdesc *v2);
 LUAI_FUNC void luaK_setlist (FuncState *fs, int base, int nelems, int tostore);
-
+LUAI_FUNC int luaK_integerK (FuncState *fs, lua_Integer r);
 
 #endif
diff -urN --exclude=.svn --exclude=.DS_Store --exclude='*.orig' --exclude='*.o' /tmp/lua-5.1.4/src/ldebug.c lua-5.1.4-patched/src/ldebug.c
--- /tmp/lua-5.1.4/src/ldebug.c	2008-05-08 19:56:26.000000000 +0300
+++ lua-5.1.4-patched/src/ldebug.c	2009-03-26 21:21:04.000000000 +0200
@@ -183,7 +183,7 @@
     int *lineinfo = f->l.p->lineinfo;
     int i;
     for (i=0; i<f->l.p->sizelineinfo; i++)
-      setbvalue(luaH_setnum(L, t, lineinfo[i]), 1);
+      setbvalue(luaH_setint(L, t, lineinfo[i]), 1);
     sethvalue(L, L->top, t); 
   }
   incr_top(L);
@@ -566,7 +566,7 @@
 
 void luaG_typeerror (lua_State *L, const TValue *o, const char *op) {
   const char *name = NULL;
-  const char *t = luaT_typenames[ttype(o)];
+  const char *t = luaT_typenames[ttype_ext(o)];
   const char *kind = (isinstack(L->ci, o)) ?
                          getobjname(L, L->ci, cast_int(o - L->base), &name) :
                          NULL;
@@ -594,8 +594,8 @@
 
 
 int luaG_ordererror (lua_State *L, const TValue *p1, const TValue *p2) {
-  const char *t1 = luaT_typenames[ttype(p1)];
-  const char *t2 = luaT_typenames[ttype(p2)];
+  const char *t1 = luaT_typenames[ttype_ext(p1)];
+  const char *t2 = luaT_typenames[ttype_ext(p2)];
   if (t1[2] == t2[2])
     luaG_runerror(L, "attempt to compare two %s values", t1);
   else
diff -urN --exclude=.svn --exclude=.DS_Store --exclude='*.orig' --exclude='*.o' /tmp/lua-5.1.4/src/ldo.c lua-5.1.4-patched/src/ldo.c
--- /tmp/lua-5.1.4/src/ldo.c	2008-01-19 00:31:22.000000000 +0200
+++ lua-5.1.4-patched/src/ldo.c	2009-03-26 21:21:04.000000000 +0200
@@ -219,9 +219,9 @@
     luaC_checkGC(L);
     htab = luaH_new(L, nvar, 1);  /* create `arg' table */
     for (i=0; i<nvar; i++)  /* put extra arguments into `arg' table */
-      setobj2n(L, luaH_setnum(L, htab, i+1), L->top - nvar + i);
+      setobj2n(L, luaH_setint(L, htab, i+1), L->top - nvar + i);
     /* store counter in field `n' */
-    setnvalue(luaH_setstr(L, htab, luaS_newliteral(L, "n")), cast_num(nvar));
+    setivalue(luaH_setstr(L, htab, luaS_newliteral(L, "n")), nvar);
   }
 #endif
   /* move fixed parameters to final position */
diff -urN --exclude=.svn --exclude=.DS_Store --exclude='*.orig' --exclude='*.o' /tmp/lua-5.1.4/src/ldump.c lua-5.1.4-patched/src/ldump.c
--- /tmp/lua-5.1.4/src/ldump.c	2007-12-27 15:02:25.000000000 +0200
+++ lua-5.1.4-patched/src/ldump.c	2009-03-26 21:21:04.000000000 +0200
@@ -52,6 +52,13 @@
  DumpVar(x,D);
 }
 
+#ifdef LUA_TINT
+static void DumpInteger(lua_Integer x, DumpState* D)
+{
+ DumpVar(x,D);
+}
+#endif
+
 static void DumpVector(const void* b, int n, size_t size, DumpState* D)
 {
  DumpInt(n,D);
@@ -92,8 +99,13 @@
    case LUA_TBOOLEAN:
 	DumpChar(bvalue(o),D);
 	break;
+#ifdef LUA_TINT
+   case LUA_TINT:
+	DumpInteger(ivalue(o),D);
+    break;
+#endif
    case LUA_TNUMBER:
-	DumpNumber(nvalue(o),D);
+	DumpNumber(nvalue_fast(o),D);
 	break;
    case LUA_TSTRING:
 	DumpString(rawtsvalue(o),D);
Binary files /tmp/lua-5.1.4/src/liblua.a and lua-5.1.4-patched/src/liblua.a differ
diff -urN --exclude=.svn --exclude=.DS_Store --exclude='*.orig' --exclude='*.o' /tmp/lua-5.1.4/src/liolib.c lua-5.1.4-patched/src/liolib.c
--- /tmp/lua-5.1.4/src/liolib.c	2008-01-18 19:47:43.000000000 +0200
+++ lua-5.1.4-patched/src/liolib.c	2009-03-26 21:21:04.000000000 +0200
@@ -9,6 +9,7 @@
 #include <stdio.h>
 #include <stdlib.h>
 #include <string.h>
+#include <ctype.h>
 
 #define liolib_c
 #define LUA_LIB
@@ -18,7 +19,8 @@
 #include "lauxlib.h"
 #include "lualib.h"
 
-
+#include "lnum.h"
+#include "llex.h"
 
 #define IO_INPUT	1
 #define IO_OUTPUT	2
@@ -269,16 +271,66 @@
 ** =======================================================
 */
 
+/*
+* NOTE: Lua's usual '*n' format specifier reads numbers as floating point,
+*       and converts to integer if they are. IN ORDER TO NOT LOSE ACCURACY,
+*       a new '*i' format specifier is added (will also be speedier, on non-
+*       FPU systems).
+*/
 
 static int read_number (lua_State *L, FILE *f) {
   lua_Number d;
   if (fscanf(f, LUA_NUMBER_SCAN, &d) == 1) {
+#ifdef LUA_TINT
+    lua_Integer tmp;
+    lua_number2integer(tmp, d);
+    if (cast_num(tmp) == d)
+        lua_pushinteger(L, tmp);
+    else
+#endif
     lua_pushnumber(L, d);
     return 1;
   }
   else return 0;  /* read fails */
 }
 
+static int read_integer (lua_State *L, FILE *f) {
+  lua_Integer i;
+  if (fscanf(f, LUA_INTEGER_SCAN, &i) == 1) {
+    lua_pushinteger(L, i);
+    return 1;
+  }
+  else return 0;  /* read fails */
+}
+
+#ifdef LNUM_COMPLEX
+static int read_complex (lua_State *L, FILE *f) {
+  /* NNN / NNNi / NNN+MMMi / NNN-MMMi */
+  lua_Number a,b;
+  if (fscanf(f, LUA_NUMBER_SCAN, &a) == 1) {
+    int c=fgetc(f);
+    switch(c) {
+        case 'i':
+            lua_pushcomplex(L, a*I);
+            return 1;
+        case '+':
+        case '-':
+            /* "i" is consumed if at the end; just 'NNN+MMM' will most likely
+             * behave as if "i" was there? (TBD: test)
+             */
+            if (fscanf(f, LUA_NUMBER_SCAN "i", &b) == 1) {
+                lua_pushcomplex(L, a+ (c=='+' ? b:-b)*I);
+                return 1;
+            }
+    }
+    ungetc( c,f );
+    lua_pushnumber(L,a);  /*real part only*/
+    return 1;
+  }
+  return 0;  /* read fails */
+}
+#endif
+
 
 static int test_eof (lua_State *L, FILE *f) {
   int c = getc(f);
@@ -352,6 +404,14 @@
           case 'n':  /* number */
             success = read_number(L, f);
             break;
+          case 'i':  /* integer (full accuracy) */
+            success = read_integer(L, f);
+            break;
+#ifdef LNUM_COMPLEX
+          case 'c':  /* complex */
+            success = read_complex(L, f);
+            break;
+#endif
           case 'l':  /* line */
             success = read_line(L, f);
             break;
@@ -412,9 +472,10 @@
   int status = 1;
   for (; nargs--; arg++) {
     if (lua_type(L, arg) == LUA_TNUMBER) {
-      /* optimization: could be done exactly as for strings */
-      status = status &&
-          fprintf(f, LUA_NUMBER_FMT, lua_tonumber(L, arg)) > 0;
+      if (lua_isinteger(L,arg))
+          status = status && fprintf(f, LUA_INTEGER_FMT, lua_tointeger(L, arg)) > 0;
+      else
+          status = status && fprintf(f, LUA_NUMBER_FMT, lua_tonumber(L, arg)) > 0;
     }
     else {
       size_t l;
@@ -457,7 +518,7 @@
   static const char *const modenames[] = {"no", "full", "line", NULL};
   FILE *f = tofile(L);
   int op = luaL_checkoption(L, 2, NULL, modenames);
-  lua_Integer sz = luaL_optinteger(L, 3, LUAL_BUFFERSIZE);
+  size_t sz = luaL_optint32(L, 3, LUAL_BUFFERSIZE);
   int res = setvbuf(f, NULL, mode[op], sz);
   return pushresult(L, res == 0, NULL);
 }
diff -urN --exclude=.svn --exclude=.DS_Store --exclude='*.orig' --exclude='*.o' /tmp/lua-5.1.4/src/llex.c lua-5.1.4-patched/src/llex.c
--- /tmp/lua-5.1.4/src/llex.c	2007-12-27 15:02:25.000000000 +0200
+++ lua-5.1.4-patched/src/llex.c	2009-03-26 21:21:04.000000000 +0200
@@ -22,6 +22,7 @@
 #include "lstring.h"
 #include "ltable.h"
 #include "lzio.h"
+#include "lnum.h"
 
 
 
@@ -41,6 +42,10 @@
     "return", "then", "true", "until", "while",
     "..", "...", "==", ">=", "<=", "~=",
     "<number>", "<name>", "<string>", "<eof>",
+    "<integer>",
+#ifdef LNUM_COMPLEX
+    "<number2>",
+#endif
     NULL
 };
 
@@ -90,7 +95,11 @@
   switch (token) {
     case TK_NAME:
     case TK_STRING:
+    case TK_INT:
     case TK_NUMBER:
+#ifdef LNUM_COMPLEX
+    case TK_NUMBER2:
+#endif
       save(ls, '\0');
       return luaZ_buffer(ls->buff);
     default:
@@ -173,23 +182,27 @@
     if (p[n] == from) p[n] = to;
 }
 
-
-static void trydecpoint (LexState *ls, SemInfo *seminfo) {
+/* TK_NUMBER (/ TK_NUMBER2) */
+static int trydecpoint (LexState *ls, SemInfo *seminfo) {
   /* format error: try to update decimal point separator */
   struct lconv *cv = localeconv();
   char old = ls->decpoint;
+  int ret;
   ls->decpoint = (cv ? cv->decimal_point[0] : '.');
   buffreplace(ls, old, ls->decpoint);  /* try updated decimal separator */
-  if (!luaO_str2d(luaZ_buffer(ls->buff), &seminfo->r)) {
+  ret= luaO_str2d(luaZ_buffer(ls->buff), &seminfo->r, NULL);
+  if (!ret) {
     /* format error with correct decimal point: no more options */
     buffreplace(ls, ls->decpoint, '.');  /* undo change (for error message) */
     luaX_lexerror(ls, "malformed number", TK_NUMBER);
   }
+  return ret;
 }
 
 
-/* LUA_NUMBER */
-static void read_numeral (LexState *ls, SemInfo *seminfo) {
+/* TK_NUMBER / TK_INT (/TK_NUMBER2) */
+static int read_numeral (LexState *ls, SemInfo *seminfo) {
+  int ret;
   lua_assert(isdigit(ls->current));
   do {
     save_and_next(ls);
@@ -200,8 +213,9 @@
     save_and_next(ls);
   save(ls, '\0');
   buffreplace(ls, '.', ls->decpoint);  /* follow locale for decimal point */
-  if (!luaO_str2d(luaZ_buffer(ls->buff), &seminfo->r))  /* format error? */
-    trydecpoint(ls, seminfo); /* try to update decimal point separator */
+  ret= luaO_str2d(luaZ_buffer(ls->buff), &seminfo->r, &seminfo->i );
+  if (!ret) return trydecpoint(ls, seminfo); /* try to update decimal point separator */
+  return ret;
 }
 
 
@@ -329,6 +343,7 @@
 }
 
 
+/* char / TK_* */
 static int llex (LexState *ls, SemInfo *seminfo) {
   luaZ_resetbuffer(ls->buff);
   for (;;) {
@@ -400,8 +415,7 @@
         }
         else if (!isdigit(ls->current)) return '.';
         else {
-          read_numeral(ls, seminfo);
-          return TK_NUMBER;
+          return read_numeral(ls, seminfo);
         }
       }
       case EOZ: {
@@ -414,8 +428,7 @@
           continue;
         }
         else if (isdigit(ls->current)) {
-          read_numeral(ls, seminfo);
-          return TK_NUMBER;
+          return read_numeral(ls, seminfo);
         }
         else if (isalpha(ls->current) || ls->current == '_') {
           /* identifier or reserved word */
diff -urN --exclude=.svn --exclude=.DS_Store --exclude='*.orig' --exclude='*.o' /tmp/lua-5.1.4/src/llex.h lua-5.1.4-patched/src/llex.h
--- /tmp/lua-5.1.4/src/llex.h	2007-12-27 15:02:25.000000000 +0200
+++ lua-5.1.4-patched/src/llex.h	2009-03-26 21:21:04.000000000 +0200
@@ -29,7 +29,10 @@
   TK_RETURN, TK_THEN, TK_TRUE, TK_UNTIL, TK_WHILE,
   /* other terminal symbols */
   TK_CONCAT, TK_DOTS, TK_EQ, TK_GE, TK_LE, TK_NE, TK_NUMBER,
-  TK_NAME, TK_STRING, TK_EOS
+  TK_NAME, TK_STRING, TK_EOS, TK_INT
+#ifdef LNUM_COMPLEX
+  , TK_NUMBER2   /* imaginary constants: Ni */ 
+#endif
 };
 
 /* number of reserved words */
@@ -39,9 +42,12 @@
 /* array with token `names' */
 LUAI_DATA const char *const luaX_tokens [];
 
-
+/* SemInfo is a local data structure of 'llex.c', used for carrying a string
+ * or a number. A separate token (TK_*) will tell, how to interpret the data.
+ */      
 typedef union {
   lua_Number r;
+  lua_Integer i;
   TString *ts;
 } SemInfo;  /* semantics information */
 
diff -urN --exclude=.svn --exclude=.DS_Store --exclude='*.orig' --exclude='*.o' /tmp/lua-5.1.4/src/llimits.h lua-5.1.4-patched/src/llimits.h
--- /tmp/lua-5.1.4/src/llimits.h	2007-12-27 15:02:25.000000000 +0200
+++ lua-5.1.4-patched/src/llimits.h	2009-03-26 21:21:04.000000000 +0200
@@ -49,6 +49,7 @@
 
 /* result of a `usual argument conversion' over lua_Number */
 typedef LUAI_UACNUMBER l_uacNumber;
+typedef LUAI_UACINTEGER l_uacInteger;
 
 
 /* internal assertions for in-house debugging */
@@ -59,7 +60,7 @@
 
 #else
 
-#define lua_assert(c)		((void)0)
+#define lua_assert(c)		((void)(0))
 #define check_exp(c,e)		(e)
 #define api_check		luai_apicheck
 
@@ -80,7 +81,6 @@
 #define cast_int(i)	cast(int, (i))
 
 
-
 /*
 ** type for virtual-machine instructions
 ** must be an unsigned with (at least) 4 bytes (see details in lopcodes.h)
diff -urN --exclude=.svn --exclude=.DS_Store --exclude='*.orig' --exclude='*.o' /tmp/lua-5.1.4/src/lmathlib.c lua-5.1.4-patched/src/lmathlib.c
--- /tmp/lua-5.1.4/src/lmathlib.c	2007-12-27 15:02:25.000000000 +0200
+++ lua-5.1.4-patched/src/lmathlib.c	2009-03-26 21:21:04.000000000 +0200
@@ -4,7 +4,6 @@
 ** See Copyright Notice in lua.h
 */
 
-
 #include <stdlib.h>
 #include <math.h>
 
@@ -16,113 +15,210 @@
 #include "lauxlib.h"
 #include "lualib.h"
 
+/* 'luai_vectpow()' as a replacement for 'cpow()'. Defined in the header; we
+ * don't intrude the code libs internal functions.
+ */
+#ifdef LNUM_COMPLEX
+# include "lnum.h"    
+#endif
 
 #undef PI
-#define PI (3.14159265358979323846)
-#define RADIANS_PER_DEGREE (PI/180.0)
-
+#ifdef LNUM_FLOAT
+# define PI (3.14159265358979323846F)
+#elif defined(M_PI)
+# define PI M_PI
+#else
+# define PI (3.14159265358979323846264338327950288)
+#endif
+#define RADIANS_PER_DEGREE (PI/180)
 
+#undef HUGE
+#ifdef LNUM_FLOAT
+# define HUGE HUGE_VALF
+#elif defined(LNUM_LDOUBLE)
+# define HUGE HUGE_VALL
+#else
+# define HUGE HUGE_VAL
+#endif
 
 static int math_abs (lua_State *L) {
-  lua_pushnumber(L, fabs(luaL_checknumber(L, 1)));
+#ifdef LNUM_COMPLEX
+  lua_pushnumber(L, _LF(cabs) (luaL_checkcomplex(L,1)));
+#else
+  lua_pushnumber(L, _LF(fabs) (luaL_checknumber(L, 1)));
+#endif
   return 1;
 }
 
 static int math_sin (lua_State *L) {
-  lua_pushnumber(L, sin(luaL_checknumber(L, 1)));
+#ifdef LNUM_COMPLEX
+  lua_pushcomplex(L, _LF(csin) (luaL_checkcomplex(L,1)));
+#else
+  lua_pushnumber(L, _LF(sin) (luaL_checknumber(L, 1)));
+#endif
   return 1;
 }
 
 static int math_sinh (lua_State *L) {
-  lua_pushnumber(L, sinh(luaL_checknumber(L, 1)));
+#ifdef LNUM_COMPLEX
+  lua_pushcomplex(L, _LF(csinh) (luaL_checkcomplex(L,1)));
+#else
+  lua_pushnumber(L, _LF(sinh) (luaL_checknumber(L, 1)));
+#endif
   return 1;
 }
 
 static int math_cos (lua_State *L) {
-  lua_pushnumber(L, cos(luaL_checknumber(L, 1)));
+#ifdef LNUM_COMPLEX
+  lua_pushcomplex(L, _LF(ccos) (luaL_checkcomplex(L,1)));
+#else
+  lua_pushnumber(L, _LF(cos) (luaL_checknumber(L, 1)));
+#endif
   return 1;
 }
 
 static int math_cosh (lua_State *L) {
-  lua_pushnumber(L, cosh(luaL_checknumber(L, 1)));
+#ifdef LNUM_COMPLEX
+  lua_pushcomplex(L, _LF(ccosh) (luaL_checkcomplex(L,1)));
+#else
+  lua_pushnumber(L, _LF(cosh) (luaL_checknumber(L, 1)));
+#endif
   return 1;
 }
 
 static int math_tan (lua_State *L) {
-  lua_pushnumber(L, tan(luaL_checknumber(L, 1)));
+#ifdef LNUM_COMPLEX
+  lua_pushcomplex(L, _LF(ctan) (luaL_checkcomplex(L,1)));
+#else
+  lua_pushnumber(L, _LF(tan) (luaL_checknumber(L, 1)));
+#endif
   return 1;
 }
 
 static int math_tanh (lua_State *L) {
-  lua_pushnumber(L, tanh(luaL_checknumber(L, 1)));
+#ifdef LNUM_COMPLEX
+  lua_pushcomplex(L, _LF(ctanh) (luaL_checkcomplex(L,1)));
+#else
+  lua_pushnumber(L, _LF(tanh) (luaL_checknumber(L, 1)));
+#endif
   return 1;
 }
 
 static int math_asin (lua_State *L) {
-  lua_pushnumber(L, asin(luaL_checknumber(L, 1)));
+#ifdef LNUM_COMPLEX
+  lua_pushcomplex(L, _LF(casin) (luaL_checkcomplex(L,1)));
+#else
+  lua_pushnumber(L, _LF(asin) (luaL_checknumber(L, 1)));
+#endif
   return 1;
 }
 
 static int math_acos (lua_State *L) {
-  lua_pushnumber(L, acos(luaL_checknumber(L, 1)));
+#ifdef LNUM_COMPLEX
+  lua_pushcomplex(L, _LF(cacos) (luaL_checkcomplex(L,1)));
+#else
+  lua_pushnumber(L, _LF(acos) (luaL_checknumber(L, 1)));
+#endif
   return 1;
 }
 
 static int math_atan (lua_State *L) {
-  lua_pushnumber(L, atan(luaL_checknumber(L, 1)));
+#ifdef LNUM_COMPLEX
+  lua_pushcomplex(L, _LF(catan) (luaL_checkcomplex(L,1)));
+#else
+  lua_pushnumber(L, _LF(atan) (luaL_checknumber(L, 1)));
+#endif
   return 1;
 }
 
 static int math_atan2 (lua_State *L) {
-  lua_pushnumber(L, atan2(luaL_checknumber(L, 1), luaL_checknumber(L, 2)));
+  /* scalars only */
+  lua_pushnumber(L, _LF(atan2) (luaL_checknumber(L, 1), luaL_checknumber(L, 2)));
   return 1;
 }
 
 static int math_ceil (lua_State *L) {
-  lua_pushnumber(L, ceil(luaL_checknumber(L, 1)));
+#ifdef LNUM_COMPLEX
+  lua_Complex v= luaL_checkcomplex(L, 1);
+  lua_pushcomplex(L, _LF(ceil) (_LF(creal)(v)) + _LF(ceil) (_LF(cimag)(v))*I);
+#else
+  lua_pushnumber(L, _LF(ceil) (luaL_checknumber(L, 1)));
+#endif
   return 1;
 }
 
 static int math_floor (lua_State *L) {
-  lua_pushnumber(L, floor(luaL_checknumber(L, 1)));
+#ifdef LNUM_COMPLEX
+  lua_Complex v= luaL_checkcomplex(L, 1);
+  lua_pushcomplex(L, _LF(floor) (_LF(creal)(v)) + _LF(floor) (_LF(cimag)(v))*I);
+#else
+  lua_pushnumber(L, _LF(floor) (luaL_checknumber(L, 1)));
+#endif
   return 1;
 }
 
-static int math_fmod (lua_State *L) {
-  lua_pushnumber(L, fmod(luaL_checknumber(L, 1), luaL_checknumber(L, 2)));
+static int math_fmod (lua_State *L) {  
+  /* scalars only */
+  lua_pushnumber(L, _LF(fmod) (luaL_checknumber(L, 1), luaL_checknumber(L, 2)));
   return 1;
 }
 
 static int math_modf (lua_State *L) {
-  double ip;
-  double fp = modf(luaL_checknumber(L, 1), &ip);
+  /* scalars only */
+  lua_Number ip;
+  lua_Number fp = _LF(modf) (luaL_checknumber(L, 1), &ip);
   lua_pushnumber(L, ip);
   lua_pushnumber(L, fp);
   return 2;
 }
 
 static int math_sqrt (lua_State *L) {
-  lua_pushnumber(L, sqrt(luaL_checknumber(L, 1)));
+#ifdef LNUM_COMPLEX
+  lua_pushcomplex(L, _LF(csqrt) (luaL_checkcomplex(L,1)));
+#else
+  lua_pushnumber(L, _LF(sqrt) (luaL_checknumber(L, 1)));
+#endif
   return 1;
 }
 
 static int math_pow (lua_State *L) {
-  lua_pushnumber(L, pow(luaL_checknumber(L, 1), luaL_checknumber(L, 2)));
+#ifdef LNUM_COMPLEX
+  /* C99 'cpow' gives somewhat inaccurate results (i.e. (-1)^2 = -1+1.2246467991474e-16i). 
+  * 'luai_vectpow' smoothens such, reusing it is the reason we need to #include "lnum.h".
+  */
+  lua_pushcomplex(L, luai_vectpow(luaL_checkcomplex(L,1), luaL_checkcomplex(L,2)));
+#else
+  lua_pushnumber(L, _LF(pow) (luaL_checknumber(L, 1), luaL_checknumber(L, 2)));
+#endif
   return 1;
 }
 
 static int math_log (lua_State *L) {
-  lua_pushnumber(L, log(luaL_checknumber(L, 1)));
+#ifdef LNUM_COMPLEX
+  lua_pushcomplex(L, _LF(clog) (luaL_checkcomplex(L,1)));
+#else
+  lua_pushnumber(L, _LF(log) (luaL_checknumber(L, 1)));
+#endif
   return 1;
 }
 
 static int math_log10 (lua_State *L) {
-  lua_pushnumber(L, log10(luaL_checknumber(L, 1)));
+#ifdef LNUM_COMPLEX
+  /* Not in standard <complex.h> , but easy to calculate: log_a(x) = log_b(x) / log_b(a) 
+  */
+  lua_pushcomplex(L, _LF(clog) (luaL_checkcomplex(L,1)) / _LF(log) (10));
+#else
+  lua_pushnumber(L, _LF(log10) (luaL_checknumber(L, 1)));
+#endif
   return 1;
 }
 
 static int math_exp (lua_State *L) {
-  lua_pushnumber(L, exp(luaL_checknumber(L, 1)));
+#ifdef LNUM_COMPLEX
+  lua_pushcomplex(L, _LF(cexp) (luaL_checkcomplex(L,1)));
+#else
+  lua_pushnumber(L, _LF(exp) (luaL_checknumber(L, 1)));
+#endif
   return 1;
 }
 
@@ -138,19 +234,20 @@
 
 static int math_frexp (lua_State *L) {
   int e;
-  lua_pushnumber(L, frexp(luaL_checknumber(L, 1), &e));
+  lua_pushnumber(L, _LF(frexp) (luaL_checknumber(L, 1), &e));
   lua_pushinteger(L, e);
   return 2;
 }
 
 static int math_ldexp (lua_State *L) {
-  lua_pushnumber(L, ldexp(luaL_checknumber(L, 1), luaL_checkint(L, 2)));
+  lua_pushnumber(L, _LF(ldexp) (luaL_checknumber(L, 1), luaL_checkint(L, 2)));
   return 1;
 }
 
 
 
 static int math_min (lua_State *L) {
+  /* scalars only */
   int n = lua_gettop(L);  /* number of arguments */
   lua_Number dmin = luaL_checknumber(L, 1);
   int i;
@@ -165,6 +262,7 @@
 
 
 static int math_max (lua_State *L) {
+  /* scalars only */
   int n = lua_gettop(L);  /* number of arguments */
   lua_Number dmax = luaL_checknumber(L, 1);
   int i;
@@ -182,25 +280,20 @@
   /* the `%' avoids the (rare) case of r==1, and is needed also because on
      some systems (SunOS!) `rand()' may return a value larger than RAND_MAX */
   lua_Number r = (lua_Number)(rand()%RAND_MAX) / (lua_Number)RAND_MAX;
-  switch (lua_gettop(L)) {  /* check number of arguments */
-    case 0: {  /* no arguments */
-      lua_pushnumber(L, r);  /* Number between 0 and 1 */
-      break;
-    }
-    case 1: {  /* only upper limit */
-      int u = luaL_checkint(L, 1);
-      luaL_argcheck(L, 1<=u, 1, "interval is empty");
-      lua_pushnumber(L, floor(r*u)+1);  /* int between 1 and `u' */
-      break;
-    }
-    case 2: {  /* lower and upper limits */
-      int l = luaL_checkint(L, 1);
-      int u = luaL_checkint(L, 2);
-      luaL_argcheck(L, l<=u, 2, "interval is empty");
-      lua_pushnumber(L, floor(r*(u-l+1))+l);  /* int between `l' and `u' */
-      break;
-    }
-    default: return luaL_error(L, "wrong number of arguments");
+  int n= lua_gettop(L);  /* number of arguments */
+  if (n==0) {	/* no arguments: range [0,1) */
+    lua_pushnumber(L, r);
+  } else if (n<=2) {	/* int range [1,u] or [l,u] */
+    int l= n==1 ? 1 : luaL_checkint(L, 1);
+    int u = luaL_checkint(L, n);
+    int tmp;
+    lua_Number d;
+    luaL_argcheck(L, l<=u, n, "interval is empty");
+    d= _LF(floor)(r*(u-l+1));
+    lua_number2int(tmp,d);
+    lua_pushinteger(L, l+tmp);
+  } else {
+    return luaL_error(L, "wrong number of arguments");
   }
   return 1;
 }
@@ -211,6 +304,66 @@
   return 0;
 }
 
+/* 
+* Lua 5.1 does not have acosh, asinh, atanh for scalars (not ANSI C)
+*/
+#if __STDC_VERSION__ >= 199901L
+static int math_acosh (lua_State *L) {
+# ifdef LNUM_COMPLEX
+  lua_pushcomplex(L, _LF(cacosh) (luaL_checkcomplex(L,1)));
+# else
+  lua_pushnumber(L, _LF(acosh) (luaL_checknumber(L,1)));
+# endif
+  return 1;
+}
+static int math_asinh (lua_State *L) {
+# ifdef LNUM_COMPLEX
+  lua_pushcomplex(L, _LF(casinh) (luaL_checkcomplex(L,1)));
+# else
+  lua_pushnumber(L, _LF(asinh) (luaL_checknumber(L,1)));
+# endif
+  return 1;
+}
+static int math_atanh (lua_State *L) {
+# ifdef LNUM_COMPLEX
+  lua_pushcomplex(L, _LF(catanh) (luaL_checkcomplex(L,1)));
+# else
+  lua_pushnumber(L, _LF(atanh) (luaL_checknumber(L,1)));
+# endif
+  return 1;
+}
+#endif
+
+/* 
+ * C99 complex functions, not covered above.
+*/
+#ifdef LNUM_COMPLEX
+static int math_arg (lua_State *L) {
+  lua_pushnumber(L, _LF(carg) (luaL_checkcomplex(L,1)));
+  return 1;
+}
+
+static int math_imag (lua_State *L) {
+  lua_pushnumber(L, _LF(cimag) (luaL_checkcomplex(L,1)));
+  return 1;
+}
+
+static int math_real (lua_State *L) {
+  lua_pushnumber(L, _LF(creal) (luaL_checkcomplex(L,1)));
+  return 1;
+}
+
+static int math_conj (lua_State *L) {
+  lua_pushcomplex(L, _LF(conj) (luaL_checkcomplex(L,1)));
+  return 1;
+}
+
+static int math_proj (lua_State *L) {
+  lua_pushcomplex(L, _LF(cproj) (luaL_checkcomplex(L,1)));
+  return 1;
+}
+#endif
+
 
 static const luaL_Reg mathlib[] = {
   {"abs",   math_abs},
@@ -241,6 +394,18 @@
   {"sqrt",  math_sqrt},
   {"tanh",   math_tanh},
   {"tan",   math_tan},
+#if __STDC_VERSION__ >= 199901L
+  {"acosh",  math_acosh},
+  {"asinh",  math_asinh},
+  {"atanh",  math_atanh},
+#endif
+#ifdef LNUM_COMPLEX
+  {"arg",   math_arg},
+  {"imag",  math_imag},
+  {"real",  math_real},
+  {"conj",  math_conj},
+  {"proj",  math_proj},
+#endif
   {NULL, NULL}
 };
 
@@ -252,8 +417,10 @@
   luaL_register(L, LUA_MATHLIBNAME, mathlib);
   lua_pushnumber(L, PI);
   lua_setfield(L, -2, "pi");
-  lua_pushnumber(L, HUGE_VAL);
+  lua_pushnumber(L, HUGE);
   lua_setfield(L, -2, "huge");
+  lua_pushinteger(L, LUA_INTEGER_MAX );
+  lua_setfield(L, -2, "hugeint");
 #if defined(LUA_COMPAT_MOD)
   lua_getfield(L, -1, "fmod");
   lua_setfield(L, -2, "mod");
diff -urN --exclude=.svn --exclude=.DS_Store --exclude='*.orig' --exclude='*.o' /tmp/lua-5.1.4/src/lnum.c lua-5.1.4-patched/src/lnum.c
--- /tmp/lua-5.1.4/src/lnum.c	1970-01-01 02:00:00.000000000 +0200
+++ lua-5.1.4-patched/src/lnum.c	2009-04-17 10:19:51.000000000 +0300
@@ -0,0 +1,321 @@
+/*
+** $Id: lnum.c,v ... $
+** Internal number model
+** See Copyright Notice in lua.h
+*/
+
+#include <stdlib.h>
+#include <math.h>
+#include <ctype.h>
+#include <string.h>
+#include <stdio.h>
+#include <errno.h>
+
+#define lnum_c
+#define LUA_CORE
+
+#include "lua.h"
+#include "llex.h"
+#include "lnum.h"
+
+/*
+** lua_real2str converts a (non-complex) number to a string.
+** lua_str2real converts a string to a (non-complex) number.
+*/
+#define lua_real2str(s,n)  sprintf((s), LUA_NUMBER_FMT, (n))
+
+/*
+* Note: Only 'strtod()' is part of ANSI C; others are C99 and
+* may need '--std=c99' compiler setting (at least on Ubuntu 7.10).
+* 
+* Visual C++ 2008 Express does not have 'strtof()', nor 'strtold()'.
+* References to '_strtold()' exist but don't compile. It seems best
+* to leave Windows users with DOUBLE only (or compile with MinGW).
+*
+* In practise, using '(long double)strtod' is a risky thing, since
+* it will cause accuracy loss in reading in numbers, and such losses
+* will pile up in later processing. Get a real 'strtold()' or don't
+* use that mode at all.
+*/
+#ifdef LNUM_DOUBLE
+# define lua_str2real	strtod
+#elif defined(LNUM_FLOAT)
+# define lua_str2real	strtof
+#elif defined(LNUM_LDOUBLE)
+# define lua_str2real	strtold
+#endif
+
+#define lua_integer2str(s,v) sprintf((s), LUA_INTEGER_FMT, (v))
+
+/* 's' is expected to be LUAI_MAXNUMBER2STR long (enough for any number)
+*/
+void luaO_num2buf( char *s, const TValue *o )
+{
+  lua_Number n;
+  lua_assert( ttisnumber(o) );
+
+  /* Reason to handle integers differently is not only speed, but accuracy as
+   * well. We want to make any integer tostring() without roundings, at all.
+   */
+#ifdef LUA_TINT
+  if (ttisint(o)) {
+    lua_integer2str( s, ivalue(o) );
+    return;
+  }
+#endif
+  n= nvalue_fast(o);
+  lua_real2str(s, n);
+
+#ifdef LNUM_COMPLEX
+  lua_Number n2= nvalue_img_fast(o);
+  if (n2!=0) {   /* Postfix with +-Ni */
+      int re0= (n == 0);
+      char *s2= re0 ? s : strchr(s,'\0'); 
+      if ((!re0) && (n2>0)) *s2++= '+';
+      lua_real2str( s2, n2 );
+      strcat(s2,"i");
+  }
+#endif
+}
+
+/*
+* If a LUA_TNUMBER has integer value, give it.
+*/
+int /*bool*/ tt_integer_valued( const TValue *o, lua_Integer *ref ) {
+  lua_Number d;
+  lua_Integer i;
+
+  lua_assert( ttype(o)==LUA_TNUMBER );
+  lua_assert( ref );
+#ifdef LNUM_COMPLEX
+  if (nvalue_img_fast(o)!=0) return 0;
+#endif
+  d= nvalue_fast(o);
+  lua_number2integer(i, d);
+  if (cast_num(i) == d) {
+    *ref= i; return 1;
+  }
+  return 0;
+}
+
+/* 
+ * Lua 5.1.3 (using 'strtod()') allows 0x+hex but not 0+octal. This is good,
+ * and we should NOT use 'autobase' (0) with 'strtoul[l]()' for this reason.
+ *
+ * Full hex range (0 .. 0xff..ff) is stored as integers, not to lose any bits.
+ * Numerical value of 0xff..ff will be -1, if used in calculations.
+ *
+ * Note: Unlike in Lua 5.1.3, hex values not fitting 'lua_Integer' are _not_
+ *       read in. This would otherwise cause a discontinuity where >= '0x80..00'
+ *       would be negative, but greater values (not fitting 'lua_Integer') would
+ *       again become positive (by being read into floating point).
+ */
+/* 0 / TK_NUMBER / TK_INT (/ TK_NUMBER2) */
+int luaO_str2d (const char *s, lua_Number *res_n, lua_Integer *res_i) {
+  char *endptr;
+  int ret;
+  unsigned LUA_INTEGER add_me= 0;
+  const char *s2= s;
+
+  /* Check integers first, if caller is allowing.
+   */
+  if (res_i) {
+    /* Note: 'v' gets U[L]LONG_MAX on possible overflow (which is > LUA_INTEGER_MAX);
+     *       we don't have to check 'errno' here.
+     *
+     * Note: we do handle ".01" etc. but _not_ with locale specific decimal
+     *       sign. There preceding values with 0 is needed.
+     */
+    unsigned LUA_INTEGER v= lua_str2ul(s, &endptr, 10);
+    if ((endptr == s) && (*s!='.') && (*s!='+') && (*s!='-')) return 0;  /* nothing numeric */
+
+    if (v <= LUA_INTEGER_MAX) {
+      if (v==0 && toupper(*endptr)=='X') {
+        errno= 0;   /* needs to be set, 'strtoul[l]' does not clear it */
+        v= lua_str2ul(endptr+1, &endptr, 16);  /* retry as hex, unsigned range */
+        if (errno==ERANGE)   /* clamped to 0xff..ff */
+          return 0;  /* reject (out of range) */
+      }
+      /* within integer range; check the tail */
+      if ((!*endptr) || isspace(*endptr)) {
+        *res_i= v;
+        while (isspace(cast(unsigned char, *endptr))) endptr++;
+        return (!*endptr) ? TK_INT : 0;
+
+      } else if (*endptr == '.') {
+        /* Already read the integer part; just fill in the fraction.
+        *
+        * Reusing the read integer part this way may or may not be optimal,
+        * depending on the platform in question (it may be faster to just
+        * re-read the whole string as a floating point number). Test your
+        * system. The tail must only contain digits and/or white space for
+        * this to work (consider '1000.00e-3').
+        *
+        * Note: other decimal points will simply reread also the integral part
+        *       (we are compatible with Lua's autodetection of locale)
+        */
+        const char *p= endptr+1;
+        while( isdigit(*p) || isspace(*p) ) p++;
+        if (*p=='\0') {
+            s2= endptr;      /* continue reading FP from the decimal point */
+            add_me= v;
+        }
+      }
+    }
+  }
+
+  /* Read floating point */
+  ret= TK_NUMBER;
+  lua_assert(res_n);
+  *res_n = lua_str2real(s2, &endptr) + cast_num(add_me);
+  if (endptr == s2) {
+    /* "xxx." will take us here, with 's2' pointing to the dot (and thus failing
+     * to read the decimal part. However, we must not make "." a number.
+     */
+    if ((*s2=='.') && (s2[1]=='\0') && s2!=s)
+      return ret;   /* ''*res_n' already right; failed 'lua_str2real()' gives 0 */
+    else
+      return 0;  /* conversion failed */
+  }
+#ifdef LNUM_COMPLEX
+  if (*endptr == 'i') { endptr++; ret= TK_NUMBER2; }
+#endif
+  if (!*endptr) return ret;
+  
+  while (isspace(cast(unsigned char, *endptr))) endptr++;
+  return (!*endptr) ? ret : 0;
+}
+
+
+/* Functions for finding out, when integer operations remain in range
+ * (and doing them).
+ */
+#ifdef LUA_TINT
+int try_addint( lua_Integer *r, lua_Integer ib, lua_Integer ic ) {
+  lua_Integer v= ib+ic; /* may overflow */
+  if (ib>0 && ic>0)      { if (v < 0) return 0; /*overflow, use floats*/ }
+  else if (ib<0 && ic<0) { if (v >= 0) return 0; }
+  *r= v;
+  return 1;
+}
+
+int try_subint( lua_Integer *r, lua_Integer ib, lua_Integer ic ) {
+  lua_Integer v= ib-ic; /* may overflow */
+  if (ib>=0 && ic<0)     { if (v < 0) return 0; /*overflow, use floats*/ }
+  else if (ib<0 && ic>0) { if (v >= 0) return 0; }
+  *r= v;
+  return 1;
+}
+
+int try_mulint( lua_Integer *r, lua_Integer ib, lua_Integer ic ) {
+  if (ib!=LUA_INTEGER_MIN && ic!=LUA_INTEGER_MIN) {
+    lua_Integer b= luai_abs(ib), c= luai_abs(ic);
+    if ( (ib==0) || (LUA_INTEGER_MAX/b >= c) ) {
+      *r= ib*ic;  /* no overflow */
+      return 1;
+    }
+  } else if (ib==0 || ic==0) {
+    *r= 0; return 1;
+  }
+
+  /* Result can be LUA_INTEGER_MIN; if it is, calculating it using floating 
+   * point will not cause accuracy loss.
+   */
+  if ( luai_nummul( cast_num(ib), cast_num(ic) ) == LUA_INTEGER_MIN ) {
+    *r= LUA_INTEGER_MIN;
+    return 1;
+  }
+  return 0;
+}
+
+int try_divint( lua_Integer *r, lua_Integer ib, lua_Integer ic ) {
+  /* N/0: leave to float side, to give an error
+  */
+  if (ic==0) return 0;
+
+  /* N/LUA_INTEGER_MIN: always non-integer results, or 0 or +1
+  */
+  if (ic==LUA_INTEGER_MIN) {
+    if (ib==LUA_INTEGER_MIN) { *r=1; return 1; }
+    if (ib==0) { *r=0; return 1; }
+
+  /* LUA_INTEGER_MIN (-2^31|63)/N: calculate using float side (either the division 
+   *    causes non-integer results, or there is no accuracy loss in int->fp->int
+   *    conversions (N=2,4,8,..,256 and N=2^30,2^29,..2^23).
+   */
+  } else if (ib==LUA_INTEGER_MIN) {
+    lua_Number d= luai_numdiv( cast_num(LUA_INTEGER_MIN), cast_num(ic) );
+    lua_Integer i; lua_number2integer(i,d);
+    if (cast_num(i)==d) { *r= i; return 1; }
+  
+  } else {
+    /* Note: We _can_ use ANSI C mod here, even on negative values, since
+     *       we only test for == 0 (the sign would be implementation dependent).
+     */
+     if (ib%ic == 0) { *r= ib/ic; return 1; }
+  }
+
+  return 0;
+}
+
+int try_modint( lua_Integer *r, lua_Integer ib, lua_Integer ic ) {
+  if (ic!=0) {
+    /* ANSI C can be trusted when b%c==0, or when values are non-negative. 
+     * b - (floor(b/c) * c)
+     *   -->
+     * + +: b - (b/c) * c (b % c can be used)
+     * - -: b - (b/c) * c (b % c could work, but not defined by ANSI C)
+     * 0 -: b - (b/c) * c (=0, b % c could work, but not defined by ANSI C)
+     * - +: b - (b/c-1) * c (when b!=-c)
+     * + -: b - (b/c-1) * c (when b!=-c)
+     *
+     * o MIN%MIN ends up 0, via overflow in calcs but that does not matter.
+     * o MIN%MAX ends up MAX-1 (and other such numbers), also after overflow,
+     *   but that does not matter, results do.
+     */
+    lua_Integer v= ib % ic;
+    if ( v!=0 && (ib<0 || ic<0) ) {
+      v= ib - ((ib/ic) - ((ib<=0 && ic<0) ? 0:1)) * ic;
+    }      
+    /* Result should always have same sign as 2nd argument. (PIL2) */
+    lua_assert( (v<0) ? (ic<0) : (v>0) ? (ic>0) : 1 );
+    *r= v;
+    return 1;
+  }
+  return 0;  /* let float side return NaN */
+}
+
+int try_powint( lua_Integer *r, lua_Integer ib, lua_Integer ic ) {
+
+    /* In FLOAT/INT32 or FLOAT|DOUBLE/INT64 modes, calculating integer powers 
+     * via FP realm may lose accuracy (i.e. 7^11 = 1977326743, which fits int32
+     * but not 23-bit float mantissa). 
+     *
+     * The current solution is dumb, but it works and uses little code. Use of
+     * integer powers is not anticipated to be very frequent (apart from 2^x,
+     * which is separately optimized).
+     */
+  if (ib==0) *r=0;
+  else if (ic<0) return 0;  /* FP realm */
+  else if (ib==2 && ic < (int)sizeof(lua_Integer)*8-1) *r= ((lua_Integer)1)<<ic;   /* 1,2,4,...2^30 | 2^62 optimization */
+  else if (ic==0) *r=1;
+  else if (luai_abs(ib)==1) *r= (ic%2) ? ib:1;
+  else {
+    lua_Integer x= ib;
+    while( --ic ) {
+      if (!try_mulint( &x, x, ib ))
+        return 0; /* FP realm */
+    }
+    *r= x;
+  }
+  return 1;
+}
+
+int try_unmint( lua_Integer *r, lua_Integer ib ) {
+  /* Negating LUA_INTEGER_MIN leaves the range. */
+  if ( ib != LUA_INTEGER_MIN )  
+    { *r= -ib; return 1; }
+  return 0;
+}
+#endif
+
diff -urN --exclude=.svn --exclude=.DS_Store --exclude='*.orig' --exclude='*.o' /tmp/lua-5.1.4/src/lnum.h lua-5.1.4-patched/src/lnum.h
--- /tmp/lua-5.1.4/src/lnum.h	1970-01-01 02:00:00.000000000 +0200
+++ lua-5.1.4-patched/src/lnum.h	2009-04-07 22:48:38.000000000 +0300
@@ -0,0 +1,119 @@
+/*
+** $Id: lnum.h,v ... $
+** Internal Number model
+** See Copyright Notice in lua.h
+*/
+
+#ifndef lnum_h
+#define lnum_h
+
+#include <math.h>
+
+#include "lobject.h"
+
+/*
+** The luai_num* macros define the primitive operations over 'lua_Number's
+** (not 'lua_Integer's, not 'lua_Complex').
+*/
+#define luai_numadd(a,b)	((a)+(b))
+#define luai_numsub(a,b)	((a)-(b))
+#define luai_nummul(a,b)	((a)*(b))
+#define luai_numdiv(a,b)	((a)/(b))
+#define luai_nummod(a,b)	((a) - _LF(floor)((a)/(b))*(b))
+#define luai_numpow(a,b)	(_LF(pow)(a,b))
+#define luai_numunm(a)		(-(a))
+#define luai_numeq(a,b)	    ((a)==(b))
+#define luai_numlt(a,b)	    ((a)<(b))
+#define luai_numle(a,b)	    ((a)<=(b))
+
+/*
+* If '-ffast-math' is used, there are no NaNs or Infs. We shouldn't pretend
+* there is.
+*/
+#ifdef __FAST_MATH__
+# define luai_numisnan(a) (0)   /* has no concept of NANs */ 
+#elif (defined __STDC_VERSION__) && (__STDC_VERSION__ >= 199901L)
+# define luai_numisnan(a) isnan(a)   /* same regardless of number size */
+#else
+# define luai_numisnan(a) (!luai_numeq((a), (a)))
+#endif
+
+#ifdef LUA_TINT
+  int try_addint( lua_Integer *r, lua_Integer ib, lua_Integer ic );
+  int try_subint( lua_Integer *r, lua_Integer ib, lua_Integer ic );
+  int try_mulint( lua_Integer *r, lua_Integer ib, lua_Integer ic );
+  int try_divint( lua_Integer *r, lua_Integer ib, lua_Integer ic );
+  int try_modint( lua_Integer *r, lua_Integer ib, lua_Integer ic );
+  int try_powint( lua_Integer *r, lua_Integer ib, lua_Integer ic );
+  int try_unmint( lua_Integer *r, lua_Integer ib );
+#endif
+
+#ifdef LNUM_COMPLEX
+  static inline lua_Complex luai_vectunm( lua_Complex a ) { return -a; }
+  static inline lua_Complex luai_vectadd( lua_Complex a, lua_Complex b ) { return a+b; }
+  static inline lua_Complex luai_vectsub( lua_Complex a, lua_Complex b ) { return a-b; }
+  static inline lua_Complex luai_vectmul( lua_Complex a, lua_Complex b ) { return a*b; }
+  static inline lua_Complex luai_vectdiv( lua_Complex a, lua_Complex b ) { return a/b; }
+
+/* 
+ * Complex power
+ *
+ * C99 'cpow' gives inaccurate results for many common cases s.a. (1i)^2 -> 
+ * -1+1.2246467991474e-16i (OS X 10.4, gcc 4.0.1 build 5367)
+ * 
+ * [(a+bi)^(c+di)] = (r^c) * exp(-d*t) * cos(c*t + d*ln(r)) +
+ *                 = (r^c) * exp(-d*t) * sin(c*t + d*ln(r)) *i
+ * r = sqrt(a^2+b^2), t = arctan( b/a )
+ * 
+ * Reference: <http://home.att.net/~srschmitt/complexnumbers.html>
+ * Could also be calculated using: x^y = exp(ln(x)*y)
+ *
+ * Note: Defined here (and not in .c) so 'lmathlib.c' can share the 
+ *       implementation.
+ */
+  static inline
+  lua_Complex luai_vectpow( lua_Complex a, lua_Complex b )
+  {
+    lua_Number ar= _LF(creal)(a), ai= _LF(cimag)(a);
+    lua_Number br= _LF(creal)(b), bi= _LF(cimag)(b);
+    
+    if (ai==0 && bi==0) {     /* a^c (real) */
+        return luai_numpow( ar, br );
+    } 
+
+    int br_int= (int)br;
+    
+    if ( ai!=0 && bi==0 && br_int==br && br_int!=0 && br_int!=INT_MIN ) { 
+        /* (a+bi)^N, N = { +-1,+-2, ... +-INT_MAX } 
+        */
+        lua_Number k= luai_numpow( _LF(sqrt) (ar*ar + ai*ai), br );
+        lua_Number cos_z, sin_z;
+
+        /* Situation depends upon c (N) in the following manner:
+         * 
+         * N%4==0                                => cos(c*t)=1, sin(c*t)=0
+         * (N*sign(b))%4==1 or (N*sign(b))%4==-3 => cos(c*t)=0, sin(c*t)=1
+         * N%4==2 or N%4==-2                     => cos(c*t)=-1, sin(c*t)=0
+         * (N*sign(b))%4==-1 or (N*sign(b))%4==3 => cos(c*t)=0, sin(c*t)=-1
+         */
+      int br_int_abs = br_int<0 ? -br_int:br_int;
+      
+      switch( (br_int_abs%4) * (br_int<0 ? -1:1) * (ai<0 ? -1:1) ) {
+        case 0:             cos_z=1, sin_z=0; break;
+        case 2: case -2:    cos_z=-1, sin_z=0; break;
+        case 1: case -3:    cos_z=0, sin_z=1; break;
+        case 3: case -1:    cos_z=0, sin_z=-1; break;
+        default:            lua_assert(0); return 0;
+      }
+      return k*cos_z + (k*sin_z)*I;
+    }
+    return _LF(cpow) ( a, b );
+  }
+#endif
+
+LUAI_FUNC int luaO_str2d (const char *s, lua_Number *res1, lua_Integer *res2);
+LUAI_FUNC void luaO_num2buf( char *s, const TValue *o );
+
+LUAI_FUNC int /*bool*/ tt_integer_valued( const TValue *o, lua_Integer *ref );
+
+#endif
diff -urN --exclude=.svn --exclude=.DS_Store --exclude='*.orig' --exclude='*.o' /tmp/lua-5.1.4/src/lobject.c lua-5.1.4-patched/src/lobject.c
--- /tmp/lua-5.1.4/src/lobject.c	2007-12-27 15:02:25.000000000 +0200
+++ lua-5.1.4-patched/src/lobject.c	2009-04-07 22:31:03.000000000 +0300
@@ -21,7 +21,8 @@
 #include "lstate.h"
 #include "lstring.h"
 #include "lvm.h"
-
+#include "llex.h"
+#include "lnum.h"
 
 
 const TValue luaO_nilobject_ = {{NULL}, LUA_TNIL};
@@ -69,38 +70,47 @@
 }
 
 
-int luaO_rawequalObj (const TValue *t1, const TValue *t2) {
-  if (ttype(t1) != ttype(t2)) return 0;
-  else switch (ttype(t1)) {
-    case LUA_TNIL:
-      return 1;
-    case LUA_TNUMBER:
-      return luai_numeq(nvalue(t1), nvalue(t2));
-    case LUA_TBOOLEAN:
-      return bvalue(t1) == bvalue(t2);  /* boolean true must be 1 !! */
-    case LUA_TLIGHTUSERDATA:
-      return pvalue(t1) == pvalue(t2);
-    default:
-      lua_assert(iscollectable(t1));
-      return gcvalue(t1) == gcvalue(t2);
+int luaO_rawequalObj (const TValue *l, const TValue *r) {
+  int tl= ttype(l), tr= ttype(r);
+  if (tl == tr) {
+    switch (tl) {
+      case LUA_TNIL:
+        return 1;
+#ifdef LUA_TINT
+      case LUA_TINT:
+        return ivalue(l) == ivalue(r);
+#endif
+      case LUA_TNUMBER:
+#ifdef LNUM_COMPLEX
+        if (!luai_numeq(nvalue_img_fast(l), nvalue_img_fast(r))) return 0;
+#endif
+        return luai_numeq(nvalue_fast(l), nvalue_fast(r));
+      case LUA_TBOOLEAN:
+        return bvalue(l) == bvalue(r);  /* boolean true must be 1 !! */
+      case LUA_TLIGHTUSERDATA:
+        return pvalue(l) == pvalue(r);
+      default:
+        lua_assert(iscollectable(l));
+        return gcvalue(l) == gcvalue(r);
+    }
   }
+#ifdef LUA_TINT
+  else if (tl==LUA_TINT && tr==LUA_TNUMBER) {
+# ifdef LNUM_COMPLEX
+    if (nvalue_img_fast(r) != 0) return 0;
+# endif
+    /* Avoid doing accuracy losing cast, if possible. */
+    lua_Integer tmp;
+    return tt_integer_valued(r,&tmp) ? (ivalue(l) == tmp)
+                : luai_numeq( cast_num(ivalue(l)), nvalue_fast(r) );
+  }
+  else if (tl==LUA_TNUMBER && tr==LUA_TINT) {
+    return luaO_rawequalObj(r,l);
+  }
+#endif
+  return 0;
 }
 
-
-int luaO_str2d (const char *s, lua_Number *result) {
-  char *endptr;
-  *result = lua_str2number(s, &endptr);
-  if (endptr == s) return 0;  /* conversion failed */
-  if (*endptr == 'x' || *endptr == 'X')  /* maybe an hexadecimal constant? */
-    *result = cast_num(strtoul(s, &endptr, 16));
-  if (*endptr == '\0') return 1;  /* most common case */
-  while (isspace(cast(unsigned char, *endptr))) endptr++;
-  if (*endptr != '\0') return 0;  /* invalid trailing characters? */
-  return 1;
-}
-
-
-
 static void pushstr (lua_State *L, const char *str) {
   setsvalue2s(L, L->top, luaS_new(L, str));
   incr_top(L);
@@ -131,7 +141,11 @@
         break;
       }
       case 'd': {
-        setnvalue(L->top, cast_num(va_arg(argp, int)));
+        /* This is tricky for 64-bit integers; maybe they even cannot be
+         * supported on all compilers; depends on the conversions applied to
+         * variable argument lists. TBD: test!
+         */
+        setivalue(L->top, (lua_Integer) va_arg(argp, l_uacInteger));
         incr_top(L);
         break;
       }
@@ -212,3 +226,4 @@
     }
   }
 }
+
diff -urN --exclude=.svn --exclude=.DS_Store --exclude='*.orig' --exclude='*.o' /tmp/lua-5.1.4/src/lobject.h lua-5.1.4-patched/src/lobject.h
--- /tmp/lua-5.1.4/src/lobject.h	2008-08-06 16:29:48.000000000 +0300
+++ lua-5.1.4-patched/src/lobject.h	2009-03-26 21:21:04.000000000 +0200
@@ -17,7 +17,11 @@
 
 
 /* tags for values visible from Lua */
-#define LAST_TAG	LUA_TTHREAD
+#if defined(LUA_TINT) && (LUA_TINT > LUA_TTHREAD)
+# define LAST_TAG   LUA_TINT
+#else
+# define LAST_TAG	LUA_TTHREAD
+#endif
 
 #define NUM_TAGS	(LAST_TAG+1)
 
@@ -59,7 +63,14 @@
 typedef union {
   GCObject *gc;
   void *p;
+#ifdef LNUM_COMPLEX
+  lua_Complex n;
+#else
   lua_Number n;
+#endif
+#ifdef LUA_TINT
+  lua_Integer i;
+#endif
   int b;
 } Value;
 
@@ -77,7 +88,21 @@
 
 /* Macros to test type */
 #define ttisnil(o)	(ttype(o) == LUA_TNIL)
-#define ttisnumber(o)	(ttype(o) == LUA_TNUMBER)
+
+#ifdef LUA_TINT
+# if (LUA_TINT & 0x0f) == LUA_TNUMBER
+#  define ttisnumber(o) ((ttype(o) & 0x0f) == LUA_TNUMBER)
+# else
+#  define ttisnumber(o) ((ttype(o) == LUA_TINT) || (ttype(o) == LUA_TNUMBER))
+# endif
+# define ttisint(o) (ttype(o) == LUA_TINT)
+#else
+# define ttisnumber(o) (ttype(o) == LUA_TNUMBER)
+#endif
+
+#ifdef LNUM_COMPLEX
+# define ttiscomplex(o) ((ttype(o) == LUA_TNUMBER) && (nvalue_img_fast(o)!=0))
+#endif
 #define ttisstring(o)	(ttype(o) == LUA_TSTRING)
 #define ttistable(o)	(ttype(o) == LUA_TTABLE)
 #define ttisfunction(o)	(ttype(o) == LUA_TFUNCTION)
@@ -90,7 +115,41 @@
 #define ttype(o)	((o)->tt)
 #define gcvalue(o)	check_exp(iscollectable(o), (o)->value.gc)
 #define pvalue(o)	check_exp(ttislightuserdata(o), (o)->value.p)
-#define nvalue(o)	check_exp(ttisnumber(o), (o)->value.n)
+
+#if defined(LUA_TINT) && (LUA_TINT&0x0f == LUA_TNUMBER)
+/* expects never to be called on <0 (LUA_TNONE) */
+# define ttype_ext(o) ( ttype(o) & 0x0f )
+#elif defined(LUA_TINT)
+# define ttype_ext(o) ( ttype(o) == LUA_TINT ? LUA_TNUMBER : ttype(o) )
+#else
+# define ttype_ext(o) ttype(o)
+#endif
+
+/* '_fast' variants are for cases where 'ttype(o)' is known to be LUA_TNUMBER
+ */
+#ifdef LNUM_COMPLEX
+# ifndef LUA_TINT
+#  error "LNUM_COMPLEX only allowed with LNUM_INTxx defined (can be changed)"
+# endif
+# define nvalue_complex_fast(o) check_exp( ttype(o)==LUA_TNUMBER, (o)->value.n )   
+# define nvalue_fast(o)     ( _LF(creal) ( nvalue_complex_fast(o) ) )
+# define nvalue_img_fast(o) ( _LF(cimag) ( nvalue_complex_fast(o) ) )
+# define nvalue_complex(o) check_exp( ttisnumber(o), (ttype(o)==LUA_TINT) ? (o)->value.i : (o)->value.n )
+# define nvalue_img(o) check_exp( ttisnumber(o), (ttype(o)==LUA_TINT) ? 0 : _LF(cimag)( (o)->value.n ) ) 
+# define nvalue(o) check_exp( ttisnumber(o), (ttype(o)==LUA_TINT) ? cast_num((o)->value.i) : _LF(creal)((o)->value.n) ) 
+/* */
+#elif defined(LUA_TINT)
+# define nvalue(o)	check_exp( ttisnumber(o), (ttype(o)==LUA_TINT) ? cast_num((o)->value.i) : (o)->value.n )
+# define nvalue_fast(o) check_exp( ttype(o)==LUA_TNUMBER, (o)->value.n )   
+#else
+# define nvalue(o)	check_exp( ttisnumber(o), (o)->value.n )
+# define nvalue_fast(o) nvalue(o)
+#endif
+
+#ifdef LUA_TINT
+# define ivalue(o)	check_exp( ttype(o)==LUA_TINT, (o)->value.i )
+#endif
+
 #define rawtsvalue(o)	check_exp(ttisstring(o), &(o)->value.gc->ts)
 #define tsvalue(o)	(&rawtsvalue(o)->tsv)
 #define rawuvalue(o)	check_exp(ttisuserdata(o), &(o)->value.gc->u)
@@ -116,8 +175,29 @@
 /* Macros to set values */
 #define setnilvalue(obj) ((obj)->tt=LUA_TNIL)
 
-#define setnvalue(obj,x) \
-  { TValue *i_o=(obj); i_o->value.n=(x); i_o->tt=LUA_TNUMBER; }
+/* Must not have side effects, 'x' may be expression.
+*/
+#define setnvalue(obj,x) { TValue *i_o=(obj); i_o->value.n= (x); i_o->tt=LUA_TNUMBER; }
+
+#ifdef LUA_TINT
+# define setivalue(obj,x) { TValue *i_o=(obj); i_o->value.i=(x); i_o->tt=LUA_TINT; }
+#else
+# define setivalue(obj,x) setnvalue(obj,cast_num(x))
+#endif
+
+/* Note: Complex always has "inline", both are C99.
+*/
+#ifdef LNUM_COMPLEX
+  static inline void setnvalue_complex_fast( TValue *obj, lua_Complex x ) {
+    lua_assert( _LF(cimag)(x) != 0 );
+    obj->value.n= x; obj->tt= LUA_TNUMBER;
+  }
+  static inline void setnvalue_complex( TValue *obj, lua_Complex x ) {
+    if (_LF(cimag)(x) == 0) { setnvalue(obj, _LF(creal)(x)); }
+    else { obj->value.n= x; obj->tt= LUA_TNUMBER; }
+  }
+#endif
+
 
 #define setpvalue(obj,x) \
   { TValue *i_o=(obj); i_o->value.p=(x); i_o->tt=LUA_TLIGHTUSERDATA; }
@@ -155,9 +235,6 @@
     i_o->value.gc=cast(GCObject *, (x)); i_o->tt=LUA_TPROTO; \
     checkliveness(G(L),i_o); }
 
-
-
-
 #define setobj(L,obj1,obj2) \
   { const TValue *o2=(obj2); TValue *o1=(obj1); \
     o1->value = o2->value; o1->tt=o2->tt; \
@@ -185,8 +262,11 @@
 
 #define setttype(obj, tt) (ttype(obj) = (tt))
 
-
-#define iscollectable(o)	(ttype(o) >= LUA_TSTRING)
+#if defined(LUA_TINT) && (LUA_TINT >= LUA_TSTRING)
+# define iscollectable(o)	((ttype(o) >= LUA_TSTRING) && (ttype(o) != LUA_TINT))
+#else
+# define iscollectable(o)	(ttype(o) >= LUA_TSTRING)
+#endif
 
 
 
@@ -370,12 +450,10 @@
 LUAI_FUNC int luaO_int2fb (unsigned int x);
 LUAI_FUNC int luaO_fb2int (int x);
 LUAI_FUNC int luaO_rawequalObj (const TValue *t1, const TValue *t2);
-LUAI_FUNC int luaO_str2d (const char *s, lua_Number *result);
 LUAI_FUNC const char *luaO_pushvfstring (lua_State *L, const char *fmt,
                                                        va_list argp);
 LUAI_FUNC const char *luaO_pushfstring (lua_State *L, const char *fmt, ...);
 LUAI_FUNC void luaO_chunkid (char *out, const char *source, size_t len);
 
-
 #endif
 
diff -urN --exclude=.svn --exclude=.DS_Store --exclude='*.orig' --exclude='*.o' /tmp/lua-5.1.4/src/loslib.c lua-5.1.4-patched/src/loslib.c
--- /tmp/lua-5.1.4/src/loslib.c	2008-01-18 18:38:18.000000000 +0200
+++ lua-5.1.4-patched/src/loslib.c	2009-03-26 21:21:04.000000000 +0200
@@ -186,15 +186,30 @@
   }
   if (t == (time_t)(-1))
     lua_pushnil(L);
-  else
-    lua_pushnumber(L, (lua_Number)t);
+  else {
+     /* On float systems the pushed value must be an integer, NOT a number.
+      * Otherwise, accuracy is lost in the time_t->float conversion.
+      */
+#ifdef LNUM_FLOAT
+     lua_pushinteger(L, (lua_Integer) t);
+#else
+     lua_pushnumber(L, (lua_Number) t);
+#endif
+     }
   return 1;
 }
 
 
 static int os_difftime (lua_State *L) {
+#ifdef LNUM_FLOAT
+  lua_Integer i= (lua_Integer)
+    difftime( (time_t)(luaL_checkinteger(L, 1)),
+              (time_t)(luaL_optinteger(L, 2, 0)));
+  lua_pushinteger(L, i);
+#else
   lua_pushnumber(L, difftime((time_t)(luaL_checknumber(L, 1)),
                              (time_t)(luaL_optnumber(L, 2, 0))));
+#endif
   return 1;
 }
 
diff -urN --exclude=.svn --exclude=.DS_Store --exclude='*.orig' --exclude='*.o' /tmp/lua-5.1.4/src/lparser.c lua-5.1.4-patched/src/lparser.c
--- /tmp/lua-5.1.4/src/lparser.c	2007-12-28 17:32:23.000000000 +0200
+++ lua-5.1.4-patched/src/lparser.c	2009-04-17 14:15:22.000000000 +0300
@@ -33,7 +33,6 @@
 
 #define luaY_checklimit(fs,v,l,m)	if ((v)>(l)) errorlimit(fs,l,m)
 
-
 /*
 ** nodes for block list (list of active blocks)
 */
@@ -72,7 +71,7 @@
   const char *msg = (fs->f->linedefined == 0) ?
     luaO_pushfstring(fs->L, "main function has more than %d %s", limit, what) :
     luaO_pushfstring(fs->L, "function at line %d has more than %d %s",
-                            fs->f->linedefined, limit, what);
+                            (fs->f->linedefined), limit, what);
   luaX_lexerror(fs->ls, msg, 0);
 }
 
@@ -733,6 +732,18 @@
       v->u.nval = ls->t.seminfo.r;
       break;
     }
+    case TK_INT: {
+      init_exp(v, VKINT, 0);
+      v->u.ival = ls->t.seminfo.i;
+      break;
+    }
+#ifdef LNUM_COMPLEX
+    case TK_NUMBER2: {
+      init_exp(v, VKNUM2, 0);
+      v->u.nval = ls->t.seminfo.r;
+      break;
+    }
+#endif
     case TK_STRING: {
       codestring(ls, v, ls->t.seminfo.ts);
       break;
@@ -1079,7 +1090,7 @@
   if (testnext(ls, ','))
     exp1(ls);  /* optional step */
   else {  /* default step = 1 */
-    luaK_codeABx(fs, OP_LOADK, fs->freereg, luaK_numberK(fs, 1));
+    luaK_codeABx(fs, OP_LOADK, fs->freereg, luaK_integerK(fs, 1));
     luaK_reserveregs(fs, 1);
   }
   forbody(ls, base, line, 1, 1);
diff -urN --exclude=.svn --exclude=.DS_Store --exclude='*.orig' --exclude='*.o' /tmp/lua-5.1.4/src/lparser.h lua-5.1.4-patched/src/lparser.h
--- /tmp/lua-5.1.4/src/lparser.h	2007-12-27 15:02:25.000000000 +0200
+++ lua-5.1.4-patched/src/lparser.h	2009-03-26 21:21:04.000000000 +0200
@@ -31,7 +31,11 @@
   VRELOCABLE,	/* info = instruction pc */
   VNONRELOC,	/* info = result register */
   VCALL,	/* info = instruction pc */
-  VVARARG	/* info = instruction pc */
+  VVARARG,	/* info = instruction pc */
+  VKINT     /* ival = integer value */
+#ifdef LNUM_COMPLEX
+  ,VKNUM2   /* nval = imaginary value */
+#endif
 } expkind;
 
 typedef struct expdesc {
@@ -39,6 +43,7 @@
   union {
     struct { int info, aux; } s;
     lua_Number nval;
+    lua_Integer ival;
   } u;
   int t;  /* patch list of `exit when true' */
   int f;  /* patch list of `exit when false' */
diff -urN --exclude=.svn --exclude=.DS_Store --exclude='*.orig' --exclude='*.o' /tmp/lua-5.1.4/src/lstate.c lua-5.1.4-patched/src/lstate.c
--- /tmp/lua-5.1.4/src/lstate.c	2008-01-03 17:20:39.000000000 +0200
+++ lua-5.1.4-patched/src/lstate.c	2009-04-07 22:34:49.000000000 +0300
@@ -7,6 +7,10 @@
 
 #include <stddef.h>
 
+#include <stdlib.h>
+#include <stdio.h>
+   /* for nan check */
+
 #define lstate_c
 #define LUA_CORE
 
@@ -22,7 +26,7 @@
 #include "lstring.h"
 #include "ltable.h"
 #include "ltm.h"
-
+#include "lnum.h"
 
 #define state_size(x)	(sizeof(x) + LUAI_EXTRASPACE)
 #define fromstate(l)	(cast(lu_byte *, (l)) - LUAI_EXTRASPACE)
diff -urN --exclude=.svn --exclude=.DS_Store --exclude='*.orig' --exclude='*.o' /tmp/lua-5.1.4/src/lstrlib.c lua-5.1.4-patched/src/lstrlib.c
--- /tmp/lua-5.1.4/src/lstrlib.c	2008-07-11 20:27:21.000000000 +0300
+++ lua-5.1.4-patched/src/lstrlib.c	2009-03-26 21:21:04.000000000 +0200
@@ -43,8 +43,8 @@
 static int str_sub (lua_State *L) {
   size_t l;
   const char *s = luaL_checklstring(L, 1, &l);
-  ptrdiff_t start = posrelat(luaL_checkinteger(L, 2), l);
-  ptrdiff_t end = posrelat(luaL_optinteger(L, 3, -1), l);
+  ptrdiff_t start = posrelat(luaL_checkint32(L, 2), l);
+  ptrdiff_t end = posrelat(luaL_optint32(L, 3, -1), l);
   if (start < 1) start = 1;
   if (end > (ptrdiff_t)l) end = (ptrdiff_t)l;
   if (start <= end)
@@ -106,8 +106,8 @@
 static int str_byte (lua_State *L) {
   size_t l;
   const char *s = luaL_checklstring(L, 1, &l);
-  ptrdiff_t posi = posrelat(luaL_optinteger(L, 2, 1), l);
-  ptrdiff_t pose = posrelat(luaL_optinteger(L, 3, posi), l);
+  ptrdiff_t posi = posrelat(luaL_optint32(L, 2, 1), l);
+  ptrdiff_t pose = posrelat(luaL_optint32(L, 3, posi), l);
   int n, i;
   if (posi <= 0) posi = 1;
   if ((size_t)pose > l) pose = l;
@@ -496,7 +496,7 @@
   size_t l1, l2;
   const char *s = luaL_checklstring(L, 1, &l1);
   const char *p = luaL_checklstring(L, 2, &l2);
-  ptrdiff_t init = posrelat(luaL_optinteger(L, 3, 1), l1) - 1;
+  ptrdiff_t init = posrelat(luaL_optint32(L, 3, 1), l1) - 1;
   if (init < 0) init = 0;
   else if ((size_t)(init) > l1) init = (ptrdiff_t)l1;
   if (find && (lua_toboolean(L, 4) ||  /* explicit request? */
@@ -690,7 +690,7 @@
 ** maximum size of each format specification (such as '%-099.99d')
 ** (+10 accounts for %99.99x plus margin of error)
 */
-#define MAX_FORMAT	(sizeof(FLAGS) + sizeof(LUA_INTFRMLEN) + 10)
+#define MAX_FORMAT	(sizeof(FLAGS) + sizeof(LUA_INTEGER_FMT)-2 + 10)
 
 
 static void addquoted (lua_State *L, luaL_Buffer *b, int arg) {
@@ -747,9 +747,9 @@
 static void addintlen (char *form) {
   size_t l = strlen(form);
   char spec = form[l - 1];
-  strcpy(form + l - 1, LUA_INTFRMLEN);
-  form[l + sizeof(LUA_INTFRMLEN) - 2] = spec;
-  form[l + sizeof(LUA_INTFRMLEN) - 1] = '\0';
+  const char *tmp= LUA_INTEGER_FMT;   /* "%lld" or "%ld" */
+  strcpy(form + l - 1, tmp+1);
+  form[l + sizeof(LUA_INTEGER_FMT)-4] = spec;
 }
 
 
@@ -777,12 +777,12 @@
         }
         case 'd':  case 'i': {
           addintlen(form);
-          sprintf(buff, form, (LUA_INTFRM_T)luaL_checknumber(L, arg));
+          sprintf(buff, form, luaL_checkinteger(L, arg));
           break;
         }
         case 'o':  case 'u':  case 'x':  case 'X': {
           addintlen(form);
-          sprintf(buff, form, (unsigned LUA_INTFRM_T)luaL_checknumber(L, arg));
+          sprintf(buff, form, (unsigned LUA_INTEGER)luaL_checkinteger(L, arg));
           break;
         }
         case 'e':  case 'E': case 'f':
diff -urN --exclude=.svn --exclude=.DS_Store --exclude='*.orig' --exclude='*.o' /tmp/lua-5.1.4/src/ltable.c lua-5.1.4-patched/src/ltable.c
--- /tmp/lua-5.1.4/src/ltable.c	2007-12-28 17:32:23.000000000 +0200
+++ lua-5.1.4-patched/src/ltable.c	2009-04-17 15:48:27.000000000 +0300
@@ -20,6 +20,8 @@
 
 #include <math.h>
 #include <string.h>
+#include <stdio.h>  
+  /* debug */
 
 #define ltable_c
 #define LUA_CORE
@@ -33,6 +35,7 @@
 #include "lobject.h"
 #include "lstate.h"
 #include "ltable.h"
+#include "lnum.h"
 
 
 /*
@@ -52,6 +55,9 @@
 #define hashstr(t,str)  hashpow2(t, (str)->tsv.hash)
 #define hashboolean(t,p)        hashpow2(t, p)
 
+#ifdef LUA_TINT
+# define hashint(t,i)    hashpow2(t,i)
+#endif
 
 /*
 ** for some types, it is better to avoid modulus by power of 2, as
@@ -63,13 +69,6 @@
 #define hashpointer(t,p)	hashmod(t, IntPoint(p))
 
 
-/*
-** number of ints inside a lua_Number
-*/
-#define numints		cast_int(sizeof(lua_Number)/sizeof(int))
-
-
-
 #define dummynode		(&dummynode_)
 
 static const Node dummynode_ = {
@@ -79,28 +78,116 @@
 
 
 /*
-** hash for lua_Numbers
-*/
-static Node *hashnum (const Table *t, lua_Number n) {
-  unsigned int a[numints];
-  int i;
-  if (luai_numeq(n, 0))  /* avoid problems with -0 */
-    return gnode(t, 0);
-  memcpy(a, &n, sizeof(a));
-  for (i = 1; i < numints; i++) a[0] += a[i];
-  return hashmod(t, a[0]);
-}
+** number of ints of lua_Number used for hashing
+*
+* OS X Intel (1.5.6): 
+*   'sizeof(long double)'==16 but gives "Bus error" if NUM_INTS is 4.
+*   The error does not seem to happen exactly at the read, but is most
+*   likely caused by random trailing bits that cause inconsistent hashes.
+*   To avoid this, fix NUM_INTS to 3 (12 bytes).
+*
+* Linux x86 (2.6.24, gcc 4.2.4):
+*   'sizeof(long double)' is 12, which works apart from LNUM_COMPLEX
+*   (and LNUM_LDOUBLE) mode (if optimized >= -O2). There, bytes 11 and 12 
+*   seem to have random bits and cause inconsistent hashes. The x87 FPU 
+*   long double is 10 bytes (80 bits). We set NUM_INTS to 2 and don't use
+*   the last 2 bytes for hashing, at all.
+*
+* Linux x86_64 (2.6.28, gcc 4.3.3):
+*   'sizeof(long double)' is 16, but only 3 ints seem to be stable (with
+*   LNUM_COMPLEX and LNUM_LDOUBLE together only 80 bits are stable).
+*
+* NOTE: We could simplify this by simply using always 2 ints or
+*   '(sizeof(lua_Number)/sizeof(int))-1' for hashing the 'long double's
+*/
+#ifndef LNUM_LDOUBLE
+/* Anything not LNUM_LDOUBLE */
+# define NUM_INTS (sizeof(lua_Number)/sizeof(int))
+#else
+# if defined(__x86_64) || defined(__i386__)
+/* Linux x86_64 or x86 */
+#  ifdef LNUM_COMPLEX
+#   define NUM_INTS 2
+#  else
+#   define NUM_INTS 3
+#  endif
+# else
+/* Default (some systems will need the -1, some won't) */
+#  define NUM_INTS ((sizeof(lua_Number)/sizeof(int))-1)
+# endif
+#endif
 
 
+/*
+** hash for lua_Numbers
+**
+** for non-complex modes, never called with 'lua_Integer' value range (s.a. 0)
+*
+* Note: Linux x86(_64) gcc 4.x, -O2/O3 and no '-fno-strict-aliasing' will 
+*       optimize out essential stuff from here, unless 'union' is used.
+*       There is no automatic way to sniff whether compiler is having strict
+*       aliasing optimizations on (use '-DNO_STRICT_ALIASING' to enable the
+*       potentially faster code path that expects they are not on).
+*/
+static Node *hashnum (const Table *t, const lua_Number v) {
+  unsigned int i,sum;
+#ifdef NO_STRICT_ALIASING
+    /* For compilers not using "strict aliasing" optimizations (or when compiling
+    * with '-fno-strict-aliasing').
+    */
+  const unsigned int *a= cast(const unsigned int*, &v);
+  sum= a[0]; for (i = 1; i < NUM_INTS; i++) sum += a[i];
+#else
+  /*
+  * This code is "strict aliasing" safe (to be used with gcc 4.x -O2 or above, 
+  * if no '-fno-strict-aliasing' is specified). Otherwise you'll be screwed. 
+  * Casting via 'char*' or 'void*' should do the same, but doesn't.
+  *
+  * Seems gcc enables strict aliasing even if '--std=c99' is not used.
+  * There is no predefined macro to detect, whether the compiler is doing
+  * strict aliasing optimizations or not. Bohoo...  --AKa 7-Apr-2009
+  */
+  union {
+    lua_Number v;
+    unsigned int a[NUM_INTS];
+  } u;
+  lua_assert( sizeof(u)==sizeof(v) );
+  u.v= v;
+  sum= u.a[0]; for (i = 1; i < NUM_INTS; i++) sum += u.a[i];
+#endif
+  return hashmod(t, sum);
+}
 
 /*
 ** returns the `main' position of an element in a table (that is, the index
 ** of its hash value)
+**
+** Floating point numbers with integer value give the hash position of the
+** integer (so they use the same table position).
 */
 static Node *mainposition (const Table *t, const TValue *key) {
   switch (ttype(key)) {
-    case LUA_TNUMBER:
-      return hashnum(t, nvalue(key));
+#ifdef LUA_TINT
+    case LUA_TINT:
+      return hashint(t,ivalue(key));
+#endif
+    case LUA_TNUMBER: {
+#ifdef LUA_TINT
+      lua_Integer i;
+      if (tt_integer_valued(key,&i)) 
+        return hashint(t, i);
+# ifdef LNUM_COMPLEX
+      /* Complex numbers are hashed by their scalar part. Pure imaginary values
+       * with scalar 0 or -0 should give same hash.
+       */
+      if (nvalue_img_fast(key)!=0 && luai_numeq(nvalue_fast(key),0))
+        return gnode(t, 0);  /* 0 and -0 to give same hash */
+# endif
+#else
+      if (luai_numeq(nvalue(key),0)) return gnode(t, 0);  /* 0 and -0 to give same hash */
+#endif
+      return hashnum(t,nvalue_fast(key));
+    }
     case LUA_TSTRING:
       return hashstr(t, rawtsvalue(key));
     case LUA_TBOOLEAN:
@@ -116,16 +203,19 @@
 /*
 ** returns the index for `key' if `key' is an appropriate key to live in
 ** the array part of the table, -1 otherwise.
+**
+** Anything <=0 is taken as not being in the array part.
 */
-static int arrayindex (const TValue *key) {
-  if (ttisnumber(key)) {
-    lua_Number n = nvalue(key);
-    int k;
-    lua_number2int(k, n);
-    if (luai_numeq(cast_num(k), n))
-      return k;
+static int arrayindex (const TValue *key, int max) {
+  lua_Integer i;
+  switch( ttype(key) ) {
+#ifdef LUA_TINT
+    case LUA_TINT:      i= ivalue(key); break;
+#endif
+    case LUA_TNUMBER:   if (tt_integer_valued(key,&i)) break;
+    default:            return -1;  /* not to be used as array index */
   }
-  return -1;  /* `key' did not match some condition */
+  return (i <= max) ? cast_int(i) : -1;
 }
 
 
@@ -137,8 +227,8 @@
 static int findindex (lua_State *L, Table *t, StkId key) {
   int i;
   if (ttisnil(key)) return -1;  /* first iteration */
-  i = arrayindex(key);
-  if (0 < i && i <= t->sizearray)  /* is `key' inside array part? */
+  i = arrayindex(key, t->sizearray);
+  if (i>0)  /* inside array part? */
     return i-1;  /* yes; that's the index (corrected to C) */
   else {
     Node *n = mainposition(t, key);
@@ -163,7 +253,7 @@
   int i = findindex(L, t, key);  /* find original element */
   for (i++; i < t->sizearray; i++) {  /* try first array part */
     if (!ttisnil(&t->array[i])) {  /* a non-nil value? */
-      setnvalue(key, cast_num(i+1));
+      setivalue(key, i+1);
       setobj2s(L, key+1, &t->array[i]);
       return 1;
     }
@@ -209,9 +299,9 @@
 
 
 static int countint (const TValue *key, int *nums) {
-  int k = arrayindex(key);
-  if (0 < k && k <= MAXASIZE) {  /* is `key' an appropriate array index? */
-    nums[ceillog2(k)]++;  /* count as such */
+  int k = arrayindex(key,MAXASIZE);
+  if (k>0) {  /* appropriate array index? */
+    nums[ceillog2( cast(unsigned int,k) )]++;  /* count as such */
     return 1;
   }
   else
@@ -308,7 +398,7 @@
     /* re-insert elements from vanishing slice */
     for (i=nasize; i<oldasize; i++) {
       if (!ttisnil(&t->array[i]))
-        setobjt2t(L, luaH_setnum(L, t, i+1), &t->array[i]);
+        setobjt2t(L, luaH_setint(L, t, i+1), &t->array[i]);
     }
     /* shrink array */
     luaM_reallocvector(L, t->array, oldasize, nasize, TValue);
@@ -409,7 +499,10 @@
     othern = mainposition(t, key2tval(mp));
     if (othern != mp) {  /* is colliding node out of its main position? */
       /* yes; move colliding node into free position */
-      while (gnext(othern) != mp) othern = gnext(othern);  /* find previous */
+      while (gnext(othern) != mp) {
+        othern = gnext(othern);  /* find previous */
+        lua_assert(othern);   /* LNUM: caught if hashing is inconsistent */ 
+      }
       gnext(othern) = n;  /* redo the chain with `n' in place of `mp' */
       *n = *mp;  /* copy colliding node into free pos. (mp->next also goes) */
       gnext(mp) = NULL;  /* now `mp' is free */
@@ -431,18 +524,29 @@
 
 /*
 ** search function for integers
+*
+* Optimize fetches to the array portion of a table (but do provide matches
+* to other 32-bit integer keys as well). The 'key' parameter is 'int' (and not 
+* 'lua_Integer') by purpose; values not fitting in an int will be fetched using
+* the generic approach (array part won't ever have them).
 */
-const TValue *luaH_getnum (Table *t, int key) {
+const TValue *luaH_getint (Table *t, int key) {
   /* (1 <= key && key <= t->sizearray) */
   if (cast(unsigned int, key-1) < cast(unsigned int, t->sizearray))
     return &t->array[key-1];
   else {
-    lua_Number nk = cast_num(key);
-    Node *n = hashnum(t, nk);
+#ifdef LUA_TINT
+    Node *n = hashint(t, key);
+    do {  /* check whether `key' is somewhere in the chain */
+      if (ttisint(gkey(n)) && (ivalue(gkey(n)) == key))
+#else
+    lua_Number key_d= cast_num(key);
+    Node *n = hashnum(t, key_d);
     do {  /* check whether `key' is somewhere in the chain */
-      if (ttisnumber(gkey(n)) && luai_numeq(nvalue(gkey(n)), nk))
+      if (ttisnumber(gkey(n)) && luai_numeq(nvalue(gkey(n)), key_d))
+#endif
         return gval(n);  /* that's it */
-      else n = gnext(n);
+      n = gnext(n);
     } while (n);
     return luaO_nilobject;
   }
@@ -467,27 +571,38 @@
 ** main search function
 */
 const TValue *luaH_get (Table *t, const TValue *key) {
+  Node *n;
   switch (ttype(key)) {
     case LUA_TNIL: return luaO_nilobject;
     case LUA_TSTRING: return luaH_getstr(t, rawtsvalue(key));
+
+#ifdef LUA_TINT
+    case LUA_TINT: {
+      int i= cast_int( ivalue(key) );
+# ifdef LNUM_INT64
+      if (i != ivalue(key)) break;   /* handle non-32 bit separately */
+# endif
+      return luaH_getint(t,i);
+#endif
+    }
     case LUA_TNUMBER: {
-      int k;
-      lua_Number n = nvalue(key);
-      lua_number2int(k, n);
-      if (luai_numeq(cast_num(k), nvalue(key))) /* index is int? */
-        return luaH_getnum(t, k);  /* use specialized version */
-      /* else go through */
-    }
-    default: {
-      Node *n = mainposition(t, key);
-      do {  /* check whether `key' is somewhere in the chain */
-        if (luaO_rawequalObj(key2tval(n), key))
-          return gval(n);  /* that's it */
-        else n = gnext(n);
-      } while (n);
-      return luaO_nilobject;
+      lua_Integer j;
+      if (!tt_integer_valued(key,&j)) break;
+# ifdef LNUM_INT64
+      if (cast_int(j) != j) break;   /* handle non-32 bit separately */
+# endif
+      return luaH_getint(t,cast_int(j));
     }
   }
+  /* general (FP numbers, >32-bit integers, tables etc.) 
+  */
+  n = mainposition(t, key);
+  do {  /* check whether `key' is somewhere in the chain */
+    if (luaO_rawequalObj(key2tval(n), key))
+      return gval(n);  /* that's it */
+    else n = gnext(n);
+  } while (n);
+  return luaO_nilobject;
 }
 
 
@@ -498,20 +613,36 @@
     return cast(TValue *, p);
   else {
     if (ttisnil(key)) luaG_runerror(L, "table index is nil");
-    else if (ttisnumber(key) && luai_numisnan(nvalue(key)))
-      luaG_runerror(L, "table index is NaN");
+    else if (ttype(key)==LUA_TNUMBER) {
+#ifdef LUA_TINT
+      /* [3.0] must use the same index slot as [3] */
+      lua_Integer i;
+      if (tt_integer_valued(key,&i)) {
+# ifdef LNUM_INT64
+        if (cast_int(i) != i) {  /* does not fit in 32 bits */
+          TValue k;
+          setivalue(&k, i);
+          return newkey(L, t, &k);
+        }
+# endif
+        return luaH_setint(L, t, cast_int(i));
+      }
+#endif
+      if (luai_numisnan(nvalue_fast(key)))
+        luaG_runerror(L, "table index is NaN");
+    }
     return newkey(L, t, key);
   }
 }
 
 
-TValue *luaH_setnum (lua_State *L, Table *t, int key) {
-  const TValue *p = luaH_getnum(t, key);
+TValue *luaH_setint (lua_State *L, Table *t, int key) {
+  const TValue *p = luaH_getint(t, key);
   if (p != luaO_nilobject)
     return cast(TValue *, p);
   else {
     TValue k;
-    setnvalue(&k, cast_num(key));
+    setivalue(&k, key);
     return newkey(L, t, &k);
   }
 }
@@ -533,20 +664,20 @@
   unsigned int i = j;  /* i is zero or a present index */
   j++;
   /* find `i' and `j' such that i is present and j is not */
-  while (!ttisnil(luaH_getnum(t, j))) {
+  while (!ttisnil(luaH_getint(t, j))) {
     i = j;
     j *= 2;
     if (j > cast(unsigned int, MAX_INT)) {  /* overflow? */
       /* table was built with bad purposes: resort to linear search */
       i = 1;
-      while (!ttisnil(luaH_getnum(t, i))) i++;
+      while (!ttisnil(luaH_getint(t, i))) i++;
       return i - 1;
     }
   }
   /* now do a binary search between them */
   while (j - i > 1) {
     unsigned int m = (i+j)/2;
-    if (ttisnil(luaH_getnum(t, m))) j = m;
+    if (ttisnil(luaH_getint(t, m))) j = m;
     else i = m;
   }
   return i;
diff -urN --exclude=.svn --exclude=.DS_Store --exclude='*.orig' --exclude='*.o' /tmp/lua-5.1.4/src/ltable.h lua-5.1.4-patched/src/ltable.h
--- /tmp/lua-5.1.4/src/ltable.h	2007-12-27 15:02:25.000000000 +0200
+++ lua-5.1.4-patched/src/ltable.h	2009-04-17 15:46:16.000000000 +0300
@@ -18,8 +18,8 @@
 #define key2tval(n)	(&(n)->i_key.tvk)
 
 
-LUAI_FUNC const TValue *luaH_getnum (Table *t, int key);
-LUAI_FUNC TValue *luaH_setnum (lua_State *L, Table *t, int key);
+LUAI_FUNC const TValue *luaH_getint (Table *t, int key);
+LUAI_FUNC TValue *luaH_setint (lua_State *L, Table *t, int key);
 LUAI_FUNC const TValue *luaH_getstr (Table *t, TString *key);
 LUAI_FUNC TValue *luaH_setstr (lua_State *L, Table *t, TString *key);
 LUAI_FUNC const TValue *luaH_get (Table *t, const TValue *key);
diff -urN --exclude=.svn --exclude=.DS_Store --exclude='*.orig' --exclude='*.o' /tmp/lua-5.1.4/src/ltm.c lua-5.1.4-patched/src/ltm.c
--- /tmp/lua-5.1.4/src/ltm.c	2007-12-27 15:02:25.000000000 +0200
+++ lua-5.1.4-patched/src/ltm.c	2009-03-26 21:21:04.000000000 +0200
@@ -19,7 +19,6 @@
 #include "ltm.h"
 
 
-
 const char *const luaT_typenames[] = {
   "nil", "boolean", "userdata", "number",
   "string", "table", "function", "userdata", "thread",
@@ -67,6 +66,11 @@
     case LUA_TUSERDATA:
       mt = uvalue(o)->metatable;
       break;
+#ifdef LUA_TINT
+    case LUA_TINT:
+      mt = G(L)->mt[LUA_TNUMBER];
+      break;
+#endif
     default:
       mt = G(L)->mt[ttype(o)];
   }
diff -urN --exclude=.svn --exclude=.DS_Store --exclude='*.orig' --exclude='*.o' /tmp/lua-5.1.4/src/lua.c lua-5.1.4-patched/src/lua.c
--- /tmp/lua-5.1.4/src/lua.c	2007-12-28 17:32:23.000000000 +0200
+++ lua-5.1.4-patched/src/lua.c	2009-04-07 12:12:59.000000000 +0300
@@ -16,7 +16,7 @@
 
 #include "lauxlib.h"
 #include "lualib.h"
-
+#include "llimits.h"
 
 
 static lua_State *globalL = NULL;
@@ -373,15 +373,22 @@
   return 0;
 }
 
-
 int main (int argc, char **argv) {
   int status;
   struct Smain s;
+
   lua_State *L = lua_open();  /* create state */
   if (L == NULL) {
     l_message(argv[0], "cannot create state: not enough memory");
     return EXIT_FAILURE;
   }
+  /* Checking 'sizeof(lua_Integer)' cannot be made in preprocessor on all compilers.
+  */
+#ifdef LNUM_INT32
+  lua_assert( sizeof(lua_Integer) == 4 );
+#elif defined(LNUM_INT64)
+  lua_assert( sizeof(lua_Integer) == 8 );
+#endif
   s.argc = argc;
   s.argv = argv;
   status = lua_cpcall(L, &pmain, &s);
diff -urN --exclude=.svn --exclude=.DS_Store --exclude='*.orig' --exclude='*.o' /tmp/lua-5.1.4/src/lua.h lua-5.1.4-patched/src/lua.h
--- /tmp/lua-5.1.4/src/lua.h	2008-08-06 16:30:12.000000000 +0300
+++ lua-5.1.4-patched/src/lua.h	2009-03-26 21:21:04.000000000 +0200
@@ -14,12 +14,15 @@
 
 
 #include "luaconf.h"
+#if defined(LUA_CORE) || defined(LUA_LIB) || defined(lua_c)
+# include "luaconf_internal.h"
+#endif
 
 
 #define LUA_VERSION	"Lua 5.1"
 #define LUA_RELEASE	"Lua 5.1.4"
 #define LUA_VERSION_NUM	501
-#define LUA_COPYRIGHT	"Copyright (C) 1994-2008 Lua.org, PUC-Rio"
+#define LUA_COPYRIGHT	"Copyright (C) 1994-2008 Lua.org, PUC-Rio" " (" LUA_LNUM ")"
 #define LUA_AUTHORS 	"R. Ierusalimschy, L. H. de Figueiredo & W. Celes"
 
 
@@ -71,6 +74,20 @@
 */
 #define LUA_TNONE		(-1)
 
+/* LUA_TINT is an internal type, not visible to applications. There are many
+ * potential values where it can be tweaked to (code autoadjusts to these):
+ *
+ * -2: not 'usual' type value; good since 'LUA_TINT' is not part of the API
+ * LUA_TNUMBER+1: shifts other type values upwards, breaking binary compatibility
+ *     not acceptable for 5.1, maybe 5.2 onwards?
+ *  9: greater than existing (5.1) type values.
+ * -13 (0xff..f3) or 0x13: 'ttisnumber()' and 'ttype_ext()' can be reduced to
+ *     bitmask operation instead of conditional (may be good for pipelined processors)
+*/
+#if defined(LNUM_INT32) || defined(LNUM_INT64)
+# define LUA_TINT (-2)
+#endif
+
 #define LUA_TNIL		0
 #define LUA_TBOOLEAN		1
 #define LUA_TLIGHTUSERDATA	2
@@ -139,6 +156,8 @@
 LUA_API int             (lua_type) (lua_State *L, int idx);
 LUA_API const char     *(lua_typename) (lua_State *L, int tp);
 
+LUA_API int             (lua_isinteger) (lua_State *L, int idx);
+
 LUA_API int            (lua_equal) (lua_State *L, int idx1, int idx2);
 LUA_API int            (lua_rawequal) (lua_State *L, int idx1, int idx2);
 LUA_API int            (lua_lessthan) (lua_State *L, int idx1, int idx2);
@@ -244,6 +263,19 @@
 LUA_API void lua_setallocf (lua_State *L, lua_Alloc f, void *ud);
 
 
+/*
+* It is unnecessary to break Lua C API 'lua_tonumber()' compatibility, just
+* because the Lua number type is complex. Most C modules would use scalars
+* only. We'll introduce new 'lua_tocomplex' and 'lua_pushcomplex' for when
+* the module really wants to use them.
+*/
+#ifdef LNUM_COMPLEX
+  #include <complex.h>
+  typedef LUA_NUMBER complex lua_Complex;
+  LUA_API lua_Complex (lua_tocomplex) (lua_State *L, int idx);
+  LUA_API void (lua_pushcomplex) (lua_State *L, lua_Complex v);
+#endif
+
 
 /* 
 ** ===============================================================
@@ -268,7 +300,12 @@
 #define lua_isboolean(L,n)	(lua_type(L, (n)) == LUA_TBOOLEAN)
 #define lua_isthread(L,n)	(lua_type(L, (n)) == LUA_TTHREAD)
 #define lua_isnone(L,n)		(lua_type(L, (n)) == LUA_TNONE)
-#define lua_isnoneornil(L, n)	(lua_type(L, (n)) <= 0)
+
+#if LUA_TINT < 0
+# define lua_isnoneornil(L, n)	( (lua_type(L,(n)) <= 0) && (lua_type(L,(n)) != LUA_TINT) )
+#else
+# define lua_isnoneornil(L, n)	(lua_type(L, (n)) <= 0)
+#endif
 
 #define lua_pushliteral(L, s)	\
 	lua_pushlstring(L, "" s, (sizeof(s)/sizeof(char))-1)
@@ -386,3 +423,4 @@
 
 
 #endif
+
Binary files /tmp/lua-5.1.4/src/luac and lua-5.1.4-patched/src/luac differ
diff -urN --exclude=.svn --exclude=.DS_Store --exclude='*.orig' --exclude='*.o' /tmp/lua-5.1.4/src/luaconf.h lua-5.1.4-patched/src/luaconf.h
--- /tmp/lua-5.1.4/src/luaconf.h	2008-02-11 18:25:08.000000000 +0200
+++ lua-5.1.4-patched/src/luaconf.h	2009-03-26 21:21:04.000000000 +0200
@@ -1,6 +1,6 @@
 /*
 ** $Id: luaconf.h,v 1.82.1.7 2008/02/11 16:25:08 roberto Exp $
-** Configuration file for Lua
+** Configuration file for Lua (external)
 ** See Copyright Notice in lua.h
 */
 
@@ -11,7 +11,6 @@
 #include <limits.h>
 #include <stddef.h>
 
-
 /*
 ** ==================================================================
 ** Search for "@@" to find all configurable definitions.
@@ -20,46 +19,6 @@
 
 
 /*
-@@ LUA_ANSI controls the use of non-ansi features.
-** CHANGE it (define it) if you want Lua to avoid the use of any
-** non-ansi feature or library.
-*/
-#if defined(__STRICT_ANSI__)
-#define LUA_ANSI
-#endif
-
-
-#if !defined(LUA_ANSI) && defined(_WIN32)
-#define LUA_WIN
-#endif
-
-#if defined(LUA_USE_LINUX)
-#define LUA_USE_POSIX
-#define LUA_USE_DLOPEN		/* needs an extra library: -ldl */
-#define LUA_USE_READLINE	/* needs some extra libraries */
-#endif
-
-#if defined(LUA_USE_MACOSX)
-#define LUA_USE_POSIX
-#define LUA_DL_DYLD		/* does not need extra library */
-#endif
-
-
-
-/*
-@@ LUA_USE_POSIX includes all functionallity listed as X/Open System
-@* Interfaces Extension (XSI).
-** CHANGE it (define it) if your system is XSI compatible.
-*/
-#if defined(LUA_USE_POSIX)
-#define LUA_USE_MKSTEMP
-#define LUA_USE_ISATTY
-#define LUA_USE_POPEN
-#define LUA_USE_ULONGJMP
-#endif
-
-
-/*
 @@ LUA_PATH and LUA_CPATH are the names of the environment variables that
 @* Lua check to set its paths.
 @@ LUA_INIT is the name of the environment variable that Lua
@@ -106,41 +65,91 @@
 
 
 /*
-@@ LUA_DIRSEP is the directory separator (for submodules).
-** CHANGE it if your machine does not use "/" as the directory separator
-** and is not Windows. (On Windows Lua automatically uses "\".)
-*/
-#if defined(_WIN32)
-#define LUA_DIRSEP	"\\"
-#else
-#define LUA_DIRSEP	"/"
-#endif
+@@ LNUM_DOUBLE |LNUM_FLOAT |LNUM_LDOUBLE: Generic Lua number mode
+@@ LNUM_INT32 | LNUM_INT64: Integer type (optional)
+@@ LNUM_COMPLEX: Define for using 'a+bi' numbers
+@*
+@* You can combine LNUM_xxx but only one of each group. I.e. 'LNUM_FLOAT
+@* LNUM_INT32 LNUM_COMPLEX' gives float range complex numbers, with 
+@* 32-bit scalar integer range optimized.
+*/
+/*#define LNUM_DOUBLE*/
 
 
 /*
-@@ LUA_PATHSEP is the character that separates templates in a path.
-@@ LUA_PATH_MARK is the string that marks the substitution points in a
-@* template.
-@@ LUA_EXECDIR in a Windows path is replaced by the executable's
-@* directory.
-@@ LUA_IGMARK is a mark to ignore all before it when bulding the
-@* luaopen_ function name.
-** CHANGE them if for some reason your system cannot use those
-** characters. (E.g., if one of those characters is a common character
-** in file/directory names.) Probably you do not need to change them.
-*/
-#define LUA_PATHSEP	";"
-#define LUA_PATH_MARK	"?"
-#define LUA_EXECDIR	"!"
-#define LUA_IGMARK	"-"
+** LUA_NUMBER is the type of floating point number in Lua
+** LUA_NUMBER_SCAN is the format for reading numbers.
+** LUA_NUMBER_FMT is the format for writing numbers.
+*/
+#ifdef LNUM_FLOAT
+# define LUA_NUMBER         float
+# define LUA_NUMBER_SCAN    "%f"
+# define LUA_NUMBER_FMT     "%g"  
+#elif defined(LNUM_LDOUBLE)
+# define LUA_NUMBER         long double
+# define LUA_NUMBER_SCAN    "%Lg"
+# define LUA_NUMBER_FMT     "%.20Lg"
+#else
+# define LUA_NUMBER	        double
+# define LUA_NUMBER_SCAN    "%lf"
+# define LUA_NUMBER_FMT     "%.14g"
+#endif
 
 
 /*
-@@ LUA_INTEGER is the integral type used by lua_pushinteger/lua_tointeger.
-** CHANGE that if ptrdiff_t is not adequate on your machine. (On most
-** machines, ptrdiff_t gives a good choice between int or long.)
+@@ LUAI_BITSINT defines the number of bits in an int.
+** CHANGE here if Lua cannot automatically detect the number of bits of
+** your machine. Probably you do not need to change this.
 */
-#define LUA_INTEGER	ptrdiff_t
+/* avoid overflows in comparison */
+#if INT_MAX-20 < 32760
+#define LUAI_BITSINT	16
+#elif INT_MAX > 2147483640L
+/* int has at least 32 bits */
+#define LUAI_BITSINT	32
+#else
+#error "you must define LUA_BITSINT with number of bits in an integer"
+#endif
+
+
+/*
+** LUA_INTEGER is the integer type used by lua_pushinteger/lua_tointeger/lua_isinteger.
+** LUA_INTEGER_SCAN is the format for reading integers
+** LUA_INTEGER_FMT is the format for writing integers
+*/
+#ifdef LNUM_INT64
+# define LUA_INTEGER	long long
+# ifdef _MSC_VER
+#  define lua_str2ul    _strtoui64
+# else
+#  define lua_str2ul    strtoull
+# endif
+# define LUA_INTEGER_SCAN "%lld"
+# define LUA_INTEGER_FMT "%lld"
+# define LUA_INTEGER_MAX 0x7fffffffffffffffLL       /* 2^63-1 */ 
+# define LUA_INTEGER_MIN (-LUA_INTEGER_MAX - 1LL)   /* -2^63 */
+/* */
+#else
+# if LUAI_BITSINT == 32
+#  define LUA_INTEGER   int
+#  define LUA_INTEGER_SCAN "%d"
+#  define LUA_INTEGER_FMT "%d"
+# else
+/* Note: 'LUA_INTEGER' being 'ptrdiff_t' (as in Lua 5.1) causes problems with
+ *       'printf()' operations. Also 'unsigned ptrdiff_t' is invalid. */
+#  define LUA_INTEGER   long
+#  define LUA_INTEGER_SCAN "%ld"
+#  define LUA_INTEGER_FMT "%ld"
+# endif
+# define LUA_INTEGER_MAX 0x7FFFFFFF             /* 2^31-1 */
+#endif
+
+#ifndef lua_str2ul
+# define lua_str2ul (unsigned LUA_INTEGER)strtoul
+#endif
+#ifndef LUA_INTEGER_MIN
+# define LUA_INTEGER_MIN (-LUA_INTEGER_MAX -1)  /* -2^16|32 */
+#endif
 
 
 /*
@@ -170,39 +179,6 @@
 
 
 /*
-@@ LUAI_FUNC is a mark for all extern functions that are not to be
-@* exported to outside modules.
-@@ LUAI_DATA is a mark for all extern (const) variables that are not to
-@* be exported to outside modules.
-** CHANGE them if you need to mark them in some special way. Elf/gcc
-** (versions 3.2 and later) mark them as "hidden" to optimize access
-** when Lua is compiled as a shared library.
-*/
-#if defined(luaall_c)
-#define LUAI_FUNC	static
-#define LUAI_DATA	/* empty */
-
-#elif defined(__GNUC__) && ((__GNUC__*100 + __GNUC_MINOR__) >= 302) && \
-      defined(__ELF__)
-#define LUAI_FUNC	__attribute__((visibility("hidden"))) extern
-#define LUAI_DATA	LUAI_FUNC
-
-#else
-#define LUAI_FUNC	extern
-#define LUAI_DATA	extern
-#endif
-
-
-
-/*
-@@ LUA_QL describes how error messages quote program elements.
-** CHANGE it if you want a different appearance.
-*/
-#define LUA_QL(x)	"'" x "'"
-#define LUA_QS		LUA_QL("%s")
-
-
-/*
 @@ LUA_IDSIZE gives the maximum size for the description of the source
 @* of a function in debug information.
 ** CHANGE it if you want a different size.
@@ -211,110 +187,15 @@
 
 
 /*
-** {==================================================================
-** Stand-alone configuration
-** ===================================================================
-*/
-
-#if defined(lua_c) || defined(luaall_c)
-
-/*
-@@ lua_stdin_is_tty detects whether the standard input is a 'tty' (that
-@* is, whether we're running lua interactively).
-** CHANGE it if you have a better definition for non-POSIX/non-Windows
-** systems.
-*/
-#if defined(LUA_USE_ISATTY)
-#include <unistd.h>
-#define lua_stdin_is_tty()	isatty(0)
-#elif defined(LUA_WIN)
-#include <io.h>
-#include <stdio.h>
-#define lua_stdin_is_tty()	_isatty(_fileno(stdin))
-#else
-#define lua_stdin_is_tty()	1  /* assume stdin is a tty */
-#endif
-
-
-/*
-@@ LUA_PROMPT is the default prompt used by stand-alone Lua.
-@@ LUA_PROMPT2 is the default continuation prompt used by stand-alone Lua.
-** CHANGE them if you want different prompts. (You can also change the
-** prompts dynamically, assigning to globals _PROMPT/_PROMPT2.)
-*/
-#define LUA_PROMPT		"> "
-#define LUA_PROMPT2		">> "
-
-
-/*
-@@ LUA_PROGNAME is the default name for the stand-alone Lua program.
-** CHANGE it if your stand-alone interpreter has a different name and
-** your system is not able to detect that name automatically.
-*/
-#define LUA_PROGNAME		"lua"
-
-
-/*
-@@ LUA_MAXINPUT is the maximum length for an input line in the
-@* stand-alone interpreter.
-** CHANGE it if you need longer lines.
-*/
-#define LUA_MAXINPUT	512
-
-
-/*
-@@ lua_readline defines how to show a prompt and then read a line from
-@* the standard input.
-@@ lua_saveline defines how to "save" a read line in a "history".
-@@ lua_freeline defines how to free a line read by lua_readline.
-** CHANGE them if you want to improve this functionality (e.g., by using
-** GNU readline and history facilities).
+@@ LUAL_BUFFERSIZE is the buffer size used by the lauxlib buffer system.
 */
-#if defined(LUA_USE_READLINE)
-#include <stdio.h>
-#include <readline/readline.h>
-#include <readline/history.h>
-#define lua_readline(L,b,p)	((void)L, ((b)=readline(p)) != NULL)
-#define lua_saveline(L,idx) \
-	if (lua_strlen(L,idx) > 0)  /* non-empty line? */ \
-	  add_history(lua_tostring(L, idx));  /* add it to history */
-#define lua_freeline(L,b)	((void)L, free(b))
-#else
-#define lua_readline(L,b,p)	\
-	((void)L, fputs(p, stdout), fflush(stdout),  /* show prompt */ \
-	fgets(b, LUA_MAXINPUT, stdin) != NULL)  /* get line */
-#define lua_saveline(L,idx)	{ (void)L; (void)idx; }
-#define lua_freeline(L,b)	{ (void)L; (void)b; }
-#endif
+#define LUAL_BUFFERSIZE		BUFSIZ
 
-#endif
 
 /* }================================================================== */
 
 
 /*
-@@ LUAI_GCPAUSE defines the default pause between garbage-collector cycles
-@* as a percentage.
-** CHANGE it if you want the GC to run faster or slower (higher values
-** mean larger pauses which mean slower collection.) You can also change
-** this value dynamically.
-*/
-#define LUAI_GCPAUSE	200  /* 200% (wait memory to double before next GC) */
-
-
-/*
-@@ LUAI_GCMUL defines the default speed of garbage collection relative to
-@* memory allocation as a percentage.
-** CHANGE it if you want to change the granularity of the garbage
-** collection. (Higher values mean coarser collections. 0 represents
-** infinity, where each step performs a full collection.) You can also
-** change this value dynamically.
-*/
-#define LUAI_GCMUL	200 /* GC runs 'twice the speed' of memory allocation */
-
-
-
-/*
 @@ LUA_COMPAT_GETN controls compatibility with old getn behavior.
 ** CHANGE it (define it) if you want exact compatibility with the
 ** behavior of setn/getn in Lua 5.0.
@@ -365,390 +246,11 @@
 */
 #define LUA_COMPAT_OPENLIB
 
-
-
-/*
-@@ luai_apicheck is the assert macro used by the Lua-C API.
-** CHANGE luai_apicheck if you want Lua to perform some checks in the
-** parameters it gets from API calls. This may slow down the interpreter
-** a bit, but may be quite useful when debugging C code that interfaces
-** with Lua. A useful redefinition is to use assert.h.
-*/
-#if defined(LUA_USE_APICHECK)
-#include <assert.h>
-#define luai_apicheck(L,o)	{ (void)L; assert(o); }
-#else
-#define luai_apicheck(L,o)	{ (void)L; }
-#endif
-
-
-/*
-@@ LUAI_BITSINT defines the number of bits in an int.
-** CHANGE here if Lua cannot automatically detect the number of bits of
-** your machine. Probably you do not need to change this.
-*/
-/* avoid overflows in comparison */
-#if INT_MAX-20 < 32760
-#define LUAI_BITSINT	16
-#elif INT_MAX > 2147483640L
-/* int has at least 32 bits */
-#define LUAI_BITSINT	32
-#else
-#error "you must define LUA_BITSINT with number of bits in an integer"
-#endif
-
-
-/*
-@@ LUAI_UINT32 is an unsigned integer with at least 32 bits.
-@@ LUAI_INT32 is an signed integer with at least 32 bits.
-@@ LUAI_UMEM is an unsigned integer big enough to count the total
-@* memory used by Lua.
-@@ LUAI_MEM is a signed integer big enough to count the total memory
-@* used by Lua.
-** CHANGE here if for some weird reason the default definitions are not
-** good enough for your machine. (The definitions in the 'else'
-** part always works, but may waste space on machines with 64-bit
-** longs.) Probably you do not need to change this.
-*/
-#if LUAI_BITSINT >= 32
-#define LUAI_UINT32	unsigned int
-#define LUAI_INT32	int
-#define LUAI_MAXINT32	INT_MAX
-#define LUAI_UMEM	size_t
-#define LUAI_MEM	ptrdiff_t
-#else
-/* 16-bit ints */
-#define LUAI_UINT32	unsigned long
-#define LUAI_INT32	long
-#define LUAI_MAXINT32	LONG_MAX
-#define LUAI_UMEM	unsigned long
-#define LUAI_MEM	long
-#endif
-
-
-/*
-@@ LUAI_MAXCALLS limits the number of nested calls.
-** CHANGE it if you need really deep recursive calls. This limit is
-** arbitrary; its only purpose is to stop infinite recursion before
-** exhausting memory.
-*/
-#define LUAI_MAXCALLS	20000
-
-
-/*
-@@ LUAI_MAXCSTACK limits the number of Lua stack slots that a C function
-@* can use.
-** CHANGE it if you need lots of (Lua) stack space for your C
-** functions. This limit is arbitrary; its only purpose is to stop C
-** functions to consume unlimited stack space. (must be smaller than
-** -LUA_REGISTRYINDEX)
-*/
-#define LUAI_MAXCSTACK	8000
-
-
-
-/*
-** {==================================================================
-** CHANGE (to smaller values) the following definitions if your system
-** has a small C stack. (Or you may want to change them to larger
-** values if your system has a large C stack and these limits are
-** too rigid for you.) Some of these constants control the size of
-** stack-allocated arrays used by the compiler or the interpreter, while
-** others limit the maximum number of recursive calls that the compiler
-** or the interpreter can perform. Values too large may cause a C stack
-** overflow for some forms of deep constructs.
-** ===================================================================
-*/
-
-
-/*
-@@ LUAI_MAXCCALLS is the maximum depth for nested C calls (short) and
-@* syntactical nested non-terminals in a program.
-*/
-#define LUAI_MAXCCALLS		200
-
-
-/*
-@@ LUAI_MAXVARS is the maximum number of local variables per function
-@* (must be smaller than 250).
-*/
-#define LUAI_MAXVARS		200
-
-
-/*
-@@ LUAI_MAXUPVALUES is the maximum number of upvalues per function
-@* (must be smaller than 250).
-*/
-#define LUAI_MAXUPVALUES	60
-
-
-/*
-@@ LUAL_BUFFERSIZE is the buffer size used by the lauxlib buffer system.
-*/
-#define LUAL_BUFFERSIZE		BUFSIZ
-
-/* }================================================================== */
-
-
-
-
-/*
-** {==================================================================
-@@ LUA_NUMBER is the type of numbers in Lua.
-** CHANGE the following definitions only if you want to build Lua
-** with a number type different from double. You may also need to
-** change lua_number2int & lua_number2integer.
-** ===================================================================
-*/
-
-#define LUA_NUMBER_DOUBLE
-#define LUA_NUMBER	double
-
-/*
-@@ LUAI_UACNUMBER is the result of an 'usual argument conversion'
-@* over a number.
-*/
-#define LUAI_UACNUMBER	double
-
-
-/*
-@@ LUA_NUMBER_SCAN is the format for reading numbers.
-@@ LUA_NUMBER_FMT is the format for writing numbers.
-@@ lua_number2str converts a number to a string.
-@@ LUAI_MAXNUMBER2STR is maximum size of previous conversion.
-@@ lua_str2number converts a string to a number.
-*/
-#define LUA_NUMBER_SCAN		"%lf"
-#define LUA_NUMBER_FMT		"%.14g"
-#define lua_number2str(s,n)	sprintf((s), LUA_NUMBER_FMT, (n))
-#define LUAI_MAXNUMBER2STR	32 /* 16 digits, sign, point, and \0 */
-#define lua_str2number(s,p)	strtod((s), (p))
-
-
-/*
-@@ The luai_num* macros define the primitive operations over numbers.
-*/
-#if defined(LUA_CORE)
-#include <math.h>
-#define luai_numadd(a,b)	((a)+(b))
-#define luai_numsub(a,b)	((a)-(b))
-#define luai_nummul(a,b)	((a)*(b))
-#define luai_numdiv(a,b)	((a)/(b))
-#define luai_nummod(a,b)	((a) - floor((a)/(b))*(b))
-#define luai_numpow(a,b)	(pow(a,b))
-#define luai_numunm(a)		(-(a))
-#define luai_numeq(a,b)		((a)==(b))
-#define luai_numlt(a,b)		((a)<(b))
-#define luai_numle(a,b)		((a)<=(b))
-#define luai_numisnan(a)	(!luai_numeq((a), (a)))
-#endif
-
-
-/*
-@@ lua_number2int is a macro to convert lua_Number to int.
-@@ lua_number2integer is a macro to convert lua_Number to lua_Integer.
-** CHANGE them if you know a faster way to convert a lua_Number to
-** int (with any rounding method and without throwing errors) in your
-** system. In Pentium machines, a naive typecast from double to int
-** in C is extremely slow, so any alternative is worth trying.
-*/
-
-/* On a Pentium, resort to a trick */
-#if defined(LUA_NUMBER_DOUBLE) && !defined(LUA_ANSI) && !defined(__SSE2__) && \
-    (defined(__i386) || defined (_M_IX86) || defined(__i386__))
-
-/* On a Microsoft compiler, use assembler */
-#if defined(_MSC_VER)
-
-#define lua_number2int(i,d)   __asm fld d   __asm fistp i
-#define lua_number2integer(i,n)		lua_number2int(i, n)
-
-/* the next trick should work on any Pentium, but sometimes clashes
-   with a DirectX idiosyncrasy */
-#else
-
-union luai_Cast { double l_d; long l_l; };
-#define lua_number2int(i,d) \
-  { volatile union luai_Cast u; u.l_d = (d) + 6755399441055744.0; (i) = u.l_l; }
-#define lua_number2integer(i,n)		lua_number2int(i, n)
-
-#endif
-
-
-/* this option always works, but may be slow */
-#else
-#define lua_number2int(i,d)	((i)=(int)(d))
-#define lua_number2integer(i,d)	((i)=(lua_Integer)(d))
-
-#endif
-
-/* }================================================================== */
-
-
-/*
-@@ LUAI_USER_ALIGNMENT_T is a type that requires maximum alignment.
-** CHANGE it if your system requires alignments larger than double. (For
-** instance, if your system supports long doubles and they must be
-** aligned in 16-byte boundaries, then you should add long double in the
-** union.) Probably you do not need to change this.
-*/
-#define LUAI_USER_ALIGNMENT_T	union { double u; void *s; long l; }
-
-
 /*
-@@ LUAI_THROW/LUAI_TRY define how Lua does exception handling.
-** CHANGE them if you prefer to use longjmp/setjmp even with C++
-** or if want/don't to use _longjmp/_setjmp instead of regular
-** longjmp/setjmp. By default, Lua handles errors with exceptions when
-** compiling as C++ code, with _longjmp/_setjmp when asked to use them,
-** and with longjmp/setjmp otherwise.
-*/
-#if defined(__cplusplus)
-/* C++ exceptions */
-#define LUAI_THROW(L,c)	throw(c)
-#define LUAI_TRY(L,c,a)	try { a } catch(...) \
-	{ if ((c)->status == 0) (c)->status = -1; }
-#define luai_jmpbuf	int  /* dummy variable */
-
-#elif defined(LUA_USE_ULONGJMP)
-/* in Unix, try _longjmp/_setjmp (more efficient) */
-#define LUAI_THROW(L,c)	_longjmp((c)->b, 1)
-#define LUAI_TRY(L,c,a)	if (_setjmp((c)->b) == 0) { a }
-#define luai_jmpbuf	jmp_buf
-
-#else
-/* default handling with long jumps */
-#define LUAI_THROW(L,c)	longjmp((c)->b, 1)
-#define LUAI_TRY(L,c,a)	if (setjmp((c)->b) == 0) { a }
-#define luai_jmpbuf	jmp_buf
-
-#endif
-
-
-/*
-@@ LUA_MAXCAPTURES is the maximum number of captures that a pattern
-@* can do during pattern-matching.
-** CHANGE it if you need more captures. This limit is arbitrary.
-*/
-#define LUA_MAXCAPTURES		32
-
-
-/*
-@@ lua_tmpnam is the function that the OS library uses to create a
-@* temporary name.
-@@ LUA_TMPNAMBUFSIZE is the maximum size of a name created by lua_tmpnam.
-** CHANGE them if you have an alternative to tmpnam (which is considered
-** insecure) or if you want the original tmpnam anyway.  By default, Lua
-** uses tmpnam except when POSIX is available, where it uses mkstemp.
-*/
-#if defined(loslib_c) || defined(luaall_c)
-
-#if defined(LUA_USE_MKSTEMP)
-#include <unistd.h>
-#define LUA_TMPNAMBUFSIZE	32
-#define lua_tmpnam(b,e)	{ \
-	strcpy(b, "/tmp/lua_XXXXXX"); \
-	e = mkstemp(b); \
-	if (e != -1) close(e); \
-	e = (e == -1); }
-
-#else
-#define LUA_TMPNAMBUFSIZE	L_tmpnam
-#define lua_tmpnam(b,e)		{ e = (tmpnam(b) == NULL); }
-#endif
-
-#endif
-
-
-/*
-@@ lua_popen spawns a new process connected to the current one through
-@* the file streams.
-** CHANGE it if you have a way to implement it in your system.
+@@ LUA_COMPAT_TOINTEGER controls compatibility with 5.1 'lua_tointeger()';
+@* allows values not fitting in 'lua_Integer' to be rounded.
 */
-#if defined(LUA_USE_POPEN)
-
-#define lua_popen(L,c,m)	((void)L, fflush(NULL), popen(c,m))
-#define lua_pclose(L,file)	((void)L, (pclose(file) != -1))
-
-#elif defined(LUA_WIN)
-
-#define lua_popen(L,c,m)	((void)L, _popen(c,m))
-#define lua_pclose(L,file)	((void)L, (_pclose(file) != -1))
-
-#else
-
-#define lua_popen(L,c,m)	((void)((void)c, m),  \
-		luaL_error(L, LUA_QL("popen") " not supported"), (FILE*)0)
-#define lua_pclose(L,file)		((void)((void)L, file), 0)
-
-#endif
-
-/*
-@@ LUA_DL_* define which dynamic-library system Lua should use.
-** CHANGE here if Lua has problems choosing the appropriate
-** dynamic-library system for your platform (either Windows' DLL, Mac's
-** dyld, or Unix's dlopen). If your system is some kind of Unix, there
-** is a good chance that it has dlopen, so LUA_DL_DLOPEN will work for
-** it.  To use dlopen you also need to adapt the src/Makefile (probably
-** adding -ldl to the linker options), so Lua does not select it
-** automatically.  (When you change the makefile to add -ldl, you must
-** also add -DLUA_USE_DLOPEN.)
-** If you do not want any kind of dynamic library, undefine all these
-** options.
-** By default, _WIN32 gets LUA_DL_DLL and MAC OS X gets LUA_DL_DYLD.
-*/
-#if defined(LUA_USE_DLOPEN)
-#define LUA_DL_DLOPEN
-#endif
-
-#if defined(LUA_WIN)
-#define LUA_DL_DLL
-#endif
-
-
-/*
-@@ LUAI_EXTRASPACE allows you to add user-specific data in a lua_State
-@* (the data goes just *before* the lua_State pointer).
-** CHANGE (define) this if you really need that. This value must be
-** a multiple of the maximum alignment required for your machine.
-*/
-#define LUAI_EXTRASPACE		0
-
-
-/*
-@@ luai_userstate* allow user-specific actions on threads.
-** CHANGE them if you defined LUAI_EXTRASPACE and need to do something
-** extra when a thread is created/deleted/resumed/yielded.
-*/
-#define luai_userstateopen(L)		((void)L)
-#define luai_userstateclose(L)		((void)L)
-#define luai_userstatethread(L,L1)	((void)L)
-#define luai_userstatefree(L)		((void)L)
-#define luai_userstateresume(L,n)	((void)L)
-#define luai_userstateyield(L,n)	((void)L)
-
-
-/*
-@@ LUA_INTFRMLEN is the length modifier for integer conversions
-@* in 'string.format'.
-@@ LUA_INTFRM_T is the integer type correspoding to the previous length
-@* modifier.
-** CHANGE them if your system supports long long or does not support long.
-*/
-
-#if defined(LUA_USELONGLONG)
-
-#define LUA_INTFRMLEN		"ll"
-#define LUA_INTFRM_T		long long
-
-#else
-
-#define LUA_INTFRMLEN		"l"
-#define LUA_INTFRM_T		long
-
-#endif
-
-
+#define LUA_COMPAT_TOINTEGER
 
 /* =================================================================== */
 
diff -urN --exclude=.svn --exclude=.DS_Store --exclude='*.orig' --exclude='*.o' /tmp/lua-5.1.4/src/luaconf_internal.h lua-5.1.4-patched/src/luaconf_internal.h
--- /tmp/lua-5.1.4/src/luaconf_internal.h	1970-01-01 02:00:00.000000000 +0200
+++ lua-5.1.4-patched/src/luaconf_internal.h	2009-04-07 22:41:30.000000000 +0300
@@ -0,0 +1,631 @@
+/*
+** $Id: luaconf_internal.h,v ... $
+** Configuration file for Lua (internal)
+** See Copyright Notice in lua.h
+*/
+
+
+#ifndef lconfig_internal_h
+#define lconfig_internal_h
+
+#ifdef lua_assert
+# include <assert.h>
+#endif
+
+/*
+** ==================================================================
+** Search for "@@" to find all configurable definitions.
+** ===================================================================
+*/
+
+
+/*
+@@ LUA_ANSI controls the use of non-ansi features.
+** CHANGE it (define it) if you want Lua to avoid the use of any
+** non-ansi feature or library.
+*/
+#if defined(__STRICT_ANSI__)
+#define LUA_ANSI
+#endif
+
+
+#if !defined(LUA_ANSI) && defined(_WIN32)
+#define LUA_WIN
+#endif
+
+#if defined(LUA_USE_LINUX)
+#define LUA_USE_POSIX
+#define LUA_USE_DLOPEN		/* needs an extra library: -ldl */
+#define LUA_USE_READLINE	/* needs some extra libraries */
+#endif
+
+#if defined(LUA_USE_MACOSX)
+#define LUA_USE_POSIX
+#define LUA_DL_DYLD		/* does not need extra library */
+#endif
+
+
+
+/*
+@@ LUA_USE_POSIX includes all functionallity listed as X/Open System
+@* Interfaces Extension (XSI).
+** CHANGE it (define it) if your system is XSI compatible.
+*/
+#if defined(LUA_USE_POSIX)
+#define LUA_USE_MKSTEMP
+#define LUA_USE_ISATTY
+#define LUA_USE_POPEN
+#define LUA_USE_ULONGJMP
+#endif
+
+
+/*
+@@ LUA_DIRSEP is the directory separator (for submodules).
+** CHANGE it if your machine does not use "/" as the directory separator
+** and is not Windows. (On Windows Lua automatically uses "\".)
+*/
+#if defined(_WIN32)
+#define LUA_DIRSEP	"\\"
+#else
+#define LUA_DIRSEP	"/"
+#endif
+
+
+/*
+@@ LUA_PATHSEP is the character that separates templates in a path.
+@@ LUA_PATH_MARK is the string that marks the substitution points in a
+@* template.
+@@ LUA_EXECDIR in a Windows path is replaced by the executable's
+@* directory.
+@@ LUA_IGMARK is a mark to ignore all before it when bulding the
+@* luaopen_ function name.
+** CHANGE them if for some reason your system cannot use those
+** characters. (E.g., if one of those characters is a common character
+** in file/directory names.) Probably you do not need to change them.
+*/
+#define LUA_PATHSEP	";"
+#define LUA_PATH_MARK	"?"
+#define LUA_EXECDIR	"!"
+#define LUA_IGMARK	"-"
+
+
+/*
+** Default number mode
+*/
+#if (!defined LNUM_DOUBLE) && (!defined LNUM_FLOAT) && (!defined LNUM_LDOUBLE)
+# define LNUM_DOUBLE
+#endif
+
+/*
+** Require C99 mode for COMPLEX, FLOAT and LDOUBLE (only DOUBLE is ANSI C).
+*/
+#if defined(LNUM_COMPLEX) && (__STDC_VERSION__ < 199901L)
+# error "Need C99 for complex (use '--std=c99' or similar)"
+#elif defined(LNUM_LDOUBLE) && (__STDC_VERSION__ < 199901L) && !defined(_MSC_VER)
+# error "Need C99 for 'long double' (use '--std=c99' or similar)"
+#elif defined(LNUM_FLOAT) && (__STDC_VERSION__ < 199901L)
+/* LNUM_FLOAT not supported on Windows */
+# error "Need C99 for 'float' (use '--std=c99' or similar)"
+#endif
+
+/*
+** COMPLEX mode currently only with integer optimization
+*/
+#if defined(LNUM_COMPLEX) && !(defined(LNUM_INT32) || defined(LNUM_INT64))
+# error "LNUM_COMPLEX needs to be used together with LNUM_INTxx"
+#endif
+ 
+/*
+** Number mode identifier to accompany the version string.
+*/
+#ifdef LNUM_COMPLEX
+# define _LNUM1 "complex "
+#else
+# define _LNUM1 ""
+#endif
+#ifdef LNUM_DOUBLE
+# define _LNUM2 "double"
+#elif defined(LNUM_FLOAT)
+# define _LNUM2 "float"
+#elif defined(LNUM_LDOUBLE)
+# define _LNUM2 "ldouble"
+#endif
+#ifdef LNUM_INT32
+# define _LNUM3 " int32"
+#elif defined(LNUM_INT64)
+# define _LNUM3 " int64"
+#else
+# define _LNUM3 ""
+#endif
+#ifdef __FAST_MATH__
+# define _LNUM4 "fastmath"
+#else
+# define _LNUM4 ""
+#endif
+#define LUA_LNUM _LNUM1 _LNUM2 _LNUM3 _LNUM4
+
+
+/* 
+** LUAI_MAXNUMBER2STR: size of a buffer fitting any number->string result.
+**
+**  double:  24 (sign, x.xxxxxxxxxxxxxxe+nnnn, and \0)
+**  int64:   21 (19 digits, sign, and \0)
+**  long double: 43 for 128-bit (sign, x.xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxe+nnnn, and \0)
+**           30 for 80-bit (sign, x.xxxxxxxxxxxxxxxxxxxxe+nnnn, and \0)
+*/
+#ifdef LNUM_LDOUBLE
+# define _LUAI_MN2S 44
+#else
+# define _LUAI_MN2S 24
+#endif
+
+#ifdef LNUM_COMPLEX
+# define LUAI_MAXNUMBER2STR (2*_LUAI_MN2S)
+#else
+# define LUAI_MAXNUMBER2STR _LUAI_MN2S
+#endif
+
+/*
+@@ lua_number2int is a macro to convert lua_Number to int.
+@@ lua_number2integer is a macro to convert lua_Number to lua_Integer.
+** CHANGE them if you know a faster way to convert a lua_Number to
+** int (with any rounding method and without throwing errors) in your
+** system. In Pentium machines, a naive typecast from double to int
+** in C is extremely slow, so any alternative is worth trying.
+**
+** Note: Using '-msse' or '-msse3' is highly recommended for newer x86
+**      processors. They have fast instructions to bypass the Pentium FP->int
+**      efficiency problem altogether.  --AKa 6-Apr-2009
+*/
+
+/* On old Pentium (SSE not enabled), resort to a trick */
+#if defined(LNUM_DOUBLE) && !defined(LUA_ANSI) && !defined(__SSE2__) && \
+    (defined(__i386) || defined (_M_IX86) || defined(__i386__))
+
+/* On a Microsoft compiler, use assembler */
+# if defined(_MSC_VER)
+#  define lua_number2int(i,d)   __asm fld d   __asm fistp i
+# else
+
+/* the next trick should work on any Pentium, but sometimes clashes
+   with a DirectX idiosyncrasy */
+union luai_Cast { double l_d; long l_l; };
+#  define lua_number2int(i,d) \
+  { volatile union luai_Cast u; u.l_d = (d) + 6755399441055744.0; (i) = u.l_l; }
+# endif
+
+# ifndef LNUM_INT64
+#  define lua_number2integer    lua_number2int
+# endif
+
+/* this option always works (and is fast on most platforms) */
+#else
+# define lua_number2int(i,d)        ((i)=(int)(d))
+#endif
+
+/* Note: Some compilers (OS X gcc 4.0?) may choke on double->long long conversion 
+ *       since it can lose precision. Others do require 'long long' there.  
+ */
+#ifndef lua_number2integer
+# define lua_number2integer(i,d)    ((i)=(lua_Integer)(d))
+#endif
+
+/*
+** 'luai_abs()' to give absolute value of 'lua_Integer'
+*/
+#ifdef LNUM_INT64
+# if (__STDC_VERSION__ >= 199901L)
+#  define luai_abs llabs
+# else
+#  define luai_abs(v) ((v) >= 0 ? (v) : -(v))
+# endif
+#else
+# define luai_abs abs
+#endif
+
+/*
+** LUAI_UACNUMBER is the result of an 'usual argument conversion' over a number.
+** LUAI_UACINTEGER the same, over an integer.
+*/
+#define LUAI_UACNUMBER	double
+#define LUAI_UACINTEGER long
+
+/* ANSI C only has math funcs for 'double. C99 required for float and long double
+ * variants.
+ */
+#ifdef LNUM_DOUBLE
+# define _LF(name) name
+#elif defined(LNUM_FLOAT)
+# define _LF(name) name ## f
+#elif defined(LNUM_LDOUBLE)
+# define _LF(name) name ## l
+#endif
+
+
+/*
+@@ LUAI_FUNC is a mark for all extern functions that are not to be
+@* exported to outside modules.
+@@ LUAI_DATA is a mark for all extern (const) variables that are not to
+@* be exported to outside modules.
+** CHANGE them if you need to mark them in some special way. Elf/gcc
+** (versions 3.2 and later) mark them as "hidden" to optimize access
+** when Lua is compiled as a shared library.
+*/
+#if defined(luaall_c)
+#define LUAI_FUNC	static
+#define LUAI_DATA	/* empty */
+
+#elif defined(__GNUC__) && ((__GNUC__*100 + __GNUC_MINOR__) >= 302) && \
+      defined(__ELF__)
+#define LUAI_FUNC	__attribute__((visibility("hidden"))) extern
+#define LUAI_DATA	LUAI_FUNC
+
+#else
+#define LUAI_FUNC	extern
+#define LUAI_DATA	extern
+#endif
+
+
+
+/*
+@@ LUA_QL describes how error messages quote program elements.
+** CHANGE it if you want a different appearance.
+*/
+#define LUA_QL(x)	"'" x "'"
+#define LUA_QS		LUA_QL("%s")
+
+
+/*
+** {==================================================================
+** Stand-alone configuration
+** ===================================================================
+*/
+
+#if defined(lua_c) || defined(luaall_c)
+
+/*
+@@ lua_stdin_is_tty detects whether the standard input is a 'tty' (that
+@* is, whether we're running lua interactively).
+** CHANGE it if you have a better definition for non-POSIX/non-Windows
+** systems.
+*/
+#if defined(LUA_USE_ISATTY)
+#include <unistd.h>
+#define lua_stdin_is_tty()	isatty(0)
+#elif defined(LUA_WIN)
+#include <io.h>
+#include <stdio.h>
+#define lua_stdin_is_tty()	_isatty(_fileno(stdin))
+#else
+#define lua_stdin_is_tty()	1  /* assume stdin is a tty */
+#endif
+
+
+/*
+@@ LUA_PROMPT is the default prompt used by stand-alone Lua.
+@@ LUA_PROMPT2 is the default continuation prompt used by stand-alone Lua.
+** CHANGE them if you want different prompts. (You can also change the
+** prompts dynamically, assigning to globals _PROMPT/_PROMPT2.)
+*/
+#define LUA_PROMPT		"> "
+#define LUA_PROMPT2		">> "
+
+
+/*
+@@ LUA_PROGNAME is the default name for the stand-alone Lua program.
+** CHANGE it if your stand-alone interpreter has a different name and
+** your system is not able to detect that name automatically.
+*/
+#define LUA_PROGNAME		"lua"
+
+
+/*
+@@ LUA_MAXINPUT is the maximum length for an input line in the
+@* stand-alone interpreter.
+** CHANGE it if you need longer lines.
+*/
+#define LUA_MAXINPUT	512
+
+
+/*
+@@ lua_readline defines how to show a prompt and then read a line from
+@* the standard input.
+@@ lua_saveline defines how to "save" a read line in a "history".
+@@ lua_freeline defines how to free a line read by lua_readline.
+** CHANGE them if you want to improve this functionality (e.g., by using
+** GNU readline and history facilities).
+*/
+#if defined(LUA_USE_READLINE)
+#include <stdio.h>
+#include <readline/readline.h>
+#include <readline/history.h>
+#define lua_readline(L,b,p)	((void)L, ((b)=readline(p)) != NULL)
+#define lua_saveline(L,idx) \
+	if (lua_strlen(L,idx) > 0)  /* non-empty line? */ \
+	  add_history(lua_tostring(L, idx));  /* add it to history */
+#define lua_freeline(L,b)	((void)L, free(b))
+#else
+#define lua_readline(L,b,p)	\
+	((void)L, fputs(p, stdout), fflush(stdout),  /* show prompt */ \
+	fgets(b, LUA_MAXINPUT, stdin) != NULL)  /* get line */
+#define lua_saveline(L,idx)	{ (void)L; (void)idx; }
+#define lua_freeline(L,b)	{ (void)L; (void)b; }
+#endif
+
+#endif
+
+/* }================================================================== */
+
+
+/*
+@@ LUAI_GCPAUSE defines the default pause between garbage-collector cycles
+@* as a percentage.
+** CHANGE it if you want the GC to run faster or slower (higher values
+** mean larger pauses which mean slower collection.) You can also change
+** this value dynamically.
+*/
+#define LUAI_GCPAUSE	200  /* 200% (wait memory to double before next GC) */
+
+
+/*
+@@ LUAI_GCMUL defines the default speed of garbage collection relative to
+@* memory allocation as a percentage.
+** CHANGE it if you want to change the granularity of the garbage
+** collection. (Higher values mean coarser collections. 0 represents
+** infinity, where each step performs a full collection.) You can also
+** change this value dynamically.
+*/
+#define LUAI_GCMUL	200 /* GC runs 'twice the speed' of memory allocation */
+
+
+/*
+@@ luai_apicheck is the assert macro used by the Lua-C API.
+** CHANGE luai_apicheck if you want Lua to perform some checks in the
+** parameters it gets from API calls. This may slow down the interpreter
+** a bit, but may be quite useful when debugging C code that interfaces
+** with Lua. A useful redefinition is to use assert.h.
+*/
+#if defined(LUA_USE_APICHECK)
+#include <assert.h>
+#define luai_apicheck(L,o)	{ (void)L; assert(o); }
+#else
+#define luai_apicheck(L,o)	{ (void)L; }
+#endif
+
+
+/*
+@@ LUAI_UINT32 is an unsigned integer with at least 32 bits.
+@@ LUAI_INT32 is an signed integer with at least 32 bits.
+@@ LUAI_UMEM is an unsigned integer big enough to count the total
+@* memory used by Lua.
+@@ LUAI_MEM is a signed integer big enough to count the total memory
+@* used by Lua.
+** CHANGE here if for some weird reason the default definitions are not
+** good enough for your machine. (The definitions in the 'else'
+** part always works, but may waste space on machines with 64-bit
+** longs.) Probably you do not need to change this.
+*/
+#if LUAI_BITSINT >= 32
+#define LUAI_UINT32	unsigned int
+#define LUAI_INT32	int
+#define LUAI_MAXINT32	INT_MAX
+#define LUAI_UMEM	size_t
+#define LUAI_MEM	ptrdiff_t
+#else
+/* 16-bit ints */
+#define LUAI_UINT32	unsigned long
+#define LUAI_INT32	long
+#define LUAI_MAXINT32	LONG_MAX
+#define LUAI_UMEM	unsigned long
+#define LUAI_MEM	long
+#endif
+
+/*
+@@ LUAI_MAXCALLS limits the number of nested calls.
+** CHANGE it if you need really deep recursive calls. This limit is
+** arbitrary; its only purpose is to stop infinite recursion before
+** exhausting memory.
+*/
+#define LUAI_MAXCALLS	20000
+
+
+/*
+@@ LUAI_MAXCSTACK limits the number of Lua stack slots that a C function
+@* can use.
+** CHANGE it if you need lots of (Lua) stack space for your C
+** functions. This limit is arbitrary; its only purpose is to stop C
+** functions to consume unlimited stack space. (must be smaller than
+** -LUA_REGISTRYINDEX)
+*/
+#define LUAI_MAXCSTACK	8000
+
+
+
+/*
+** {==================================================================
+** CHANGE (to smaller values) the following definitions if your system
+** has a small C stack. (Or you may want to change them to larger
+** values if your system has a large C stack and these limits are
+** too rigid for you.) Some of these constants control the size of
+** stack-allocated arrays used by the compiler or the interpreter, while
+** others limit the maximum number of recursive calls that the compiler
+** or the interpreter can perform. Values too large may cause a C stack
+** overflow for some forms of deep constructs.
+** ===================================================================
+*/
+
+
+/*
+@@ LUAI_MAXCCALLS is the maximum depth for nested C calls (short) and
+@* syntactical nested non-terminals in a program.
+*/
+#define LUAI_MAXCCALLS		200
+
+
+/*
+@@ LUAI_MAXVARS is the maximum number of local variables per function
+@* (must be smaller than 250).
+*/
+#define LUAI_MAXVARS		200
+
+
+/*
+@@ LUAI_MAXUPVALUES is the maximum number of upvalues per function
+@* (must be smaller than 250).
+*/
+#define LUAI_MAXUPVALUES	60
+
+
+/* }================================================================== */
+
+
+/*
+@@ LUAI_USER_ALIGNMENT_T is a type that requires maximum alignment.
+*/
+#define LUAI_USER_ALIGNMENT_T	union { LUA_NUMBER u; void *s; long l; }
+
+
+/*
+@@ LUAI_THROW/LUAI_TRY define how Lua does exception handling.
+** CHANGE them if you prefer to use longjmp/setjmp even with C++
+** or if want/don't to use _longjmp/_setjmp instead of regular
+** longjmp/setjmp. By default, Lua handles errors with exceptions when
+** compiling as C++ code, with _longjmp/_setjmp when asked to use them,
+** and with longjmp/setjmp otherwise.
+*/
+#if defined(__cplusplus)
+/* C++ exceptions */
+#define LUAI_THROW(L,c)	throw(c)
+#define LUAI_TRY(L,c,a)	try { a } catch(...) \
+	{ if ((c)->status == 0) (c)->status = -1; }
+#define luai_jmpbuf	int  /* dummy variable */
+
+#elif defined(LUA_USE_ULONGJMP)
+/* in Unix, try _longjmp/_setjmp (more efficient) */
+#define LUAI_THROW(L,c)	_longjmp((c)->b, 1)
+#define LUAI_TRY(L,c,a)	if (_setjmp((c)->b) == 0) { a }
+#define luai_jmpbuf	jmp_buf
+
+#else
+/* default handling with long jumps */
+#define LUAI_THROW(L,c)	longjmp((c)->b, 1)
+#define LUAI_TRY(L,c,a)	if (setjmp((c)->b) == 0) { a }
+#define luai_jmpbuf	jmp_buf
+
+#endif
+
+
+/*
+@@ LUA_MAXCAPTURES is the maximum number of captures that a pattern
+@* can do during pattern-matching.
+** CHANGE it if you need more captures. This limit is arbitrary.
+*/
+#define LUA_MAXCAPTURES		32
+
+
+/*
+@@ lua_tmpnam is the function that the OS library uses to create a
+@* temporary name.
+@@ LUA_TMPNAMBUFSIZE is the maximum size of a name created by lua_tmpnam.
+** CHANGE them if you have an alternative to tmpnam (which is considered
+** insecure) or if you want the original tmpnam anyway.  By default, Lua
+** uses tmpnam except when POSIX is available, where it uses mkstemp.
+*/
+#if defined(loslib_c) || defined(luaall_c)
+
+#if defined(LUA_USE_MKSTEMP)
+#include <unistd.h>
+#define LUA_TMPNAMBUFSIZE	32
+#define lua_tmpnam(b,e)	{ \
+	strcpy(b, "/tmp/lua_XXXXXX"); \
+	e = mkstemp(b); \
+	if (e != -1) close(e); \
+	e = (e == -1); }
+
+#else
+#define LUA_TMPNAMBUFSIZE	L_tmpnam
+#define lua_tmpnam(b,e)		{ e = (tmpnam(b) == NULL); }
+#endif
+
+#endif
+
+
+/*
+@@ lua_popen spawns a new process connected to the current one through
+@* the file streams.
+** CHANGE it if you have a way to implement it in your system.
+*/
+#if defined(LUA_USE_POPEN)
+
+#define lua_popen(L,c,m)	((void)L, fflush(NULL), popen(c,m))
+#define lua_pclose(L,file)	((void)L, (pclose(file) != -1))
+
+#elif defined(LUA_WIN)
+
+#define lua_popen(L,c,m)	((void)L, _popen(c,m))
+#define lua_pclose(L,file)	((void)L, (_pclose(file) != -1))
+
+#else
+
+#define lua_popen(L,c,m)	((void)((void)c, m),  \
+		luaL_error(L, LUA_QL("popen") " not supported"), (FILE*)0)
+#define lua_pclose(L,file)		((void)((void)L, file), 0)
+
+#endif
+
+/*
+@@ LUA_DL_* define which dynamic-library system Lua should use.
+** CHANGE here if Lua has problems choosing the appropriate
+** dynamic-library system for your platform (either Windows' DLL, Mac's
+** dyld, or Unix's dlopen). If your system is some kind of Unix, there
+** is a good chance that it has dlopen, so LUA_DL_DLOPEN will work for
+** it.  To use dlopen you also need to adapt the src/Makefile (probably
+** adding -ldl to the linker options), so Lua does not select it
+** automatically.  (When you change the makefile to add -ldl, you must
+** also add -DLUA_USE_DLOPEN.)
+** If you do not want any kind of dynamic library, undefine all these
+** options.
+** By default, _WIN32 gets LUA_DL_DLL and Mac OS X gets LUA_DL_DYLD.
+*/
+#if defined(LUA_USE_DLOPEN)
+#define LUA_DL_DLOPEN
+#endif
+
+#if defined(LUA_WIN)
+#define LUA_DL_DLL
+#endif
+
+
+/*
+@@ LUAI_EXTRASPACE allows you to add user-specific data in a lua_State
+@* (the data goes just *before* the lua_State pointer).
+** CHANGE (define) this if you really need that. This value must be
+** a multiple of the maximum alignment required for your machine.
+*/
+#define LUAI_EXTRASPACE		0
+
+
+/*
+@@ luai_userstate* allow user-specific actions on threads.
+** CHANGE them if you defined LUAI_EXTRASPACE and need to do something
+** extra when a thread is created/deleted/resumed/yielded.
+*/
+#define luai_userstateopen(L)		((void)L)
+#define luai_userstateclose(L)		((void)L)
+#define luai_userstatethread(L,L1)	((void)L)
+#define luai_userstatefree(L)		((void)L)
+#define luai_userstateresume(L,n)	((void)L)
+#define luai_userstateyield(L,n)	((void)L)
+
+
+/* =================================================================== */
+
+/*
+** Local configuration. You can use this space to add your redefinitions
+** without modifying the main part of the file.
+*/
+
+
+
+#endif
+
diff -urN --exclude=.svn --exclude=.DS_Store --exclude='*.orig' --exclude='*.o' /tmp/lua-5.1.4/src/lualib.h lua-5.1.4-patched/src/lualib.h
--- /tmp/lua-5.1.4/src/lualib.h	2007-12-27 15:02:25.000000000 +0200
+++ lua-5.1.4-patched/src/lualib.h	2009-03-26 21:21:04.000000000 +0200
@@ -46,7 +46,7 @@
 
 
 #ifndef lua_assert
-#define lua_assert(x)	((void)0)
+#define lua_assert(x)	((void)(0))
 #endif
 
 
diff -urN --exclude=.svn --exclude=.DS_Store --exclude='*.orig' --exclude='*.o' /tmp/lua-5.1.4/src/lundump.c lua-5.1.4-patched/src/lundump.c
--- /tmp/lua-5.1.4/src/lundump.c	2008-04-04 22:51:41.000000000 +0300
+++ lua-5.1.4-patched/src/lundump.c	2009-03-26 21:21:04.000000000 +0200
@@ -73,6 +73,15 @@
  return x;
 }
 
+#ifdef LUA_TINT
+static lua_Integer LoadInteger(LoadState* S)
+{
+ lua_Integer x;
+ LoadVar(S,x);
+ return x;
+}
+#endif
+
 static TString* LoadString(LoadState* S)
 {
  size_t size;
@@ -119,6 +128,11 @@
    case LUA_TNUMBER:
 	setnvalue(o,LoadNumber(S));
 	break;
+#ifdef LUA_TINT
+   case LUA_TINT:   /* Integer type saved in bytecode (see lcode.c) */
+	setivalue(o,LoadInteger(S));
+	break;
+#endif
    case LUA_TSTRING:
 	setsvalue2n(S->L,o,LoadString(S));
 	break;
@@ -223,5 +237,19 @@
  *h++=(char)sizeof(size_t);
  *h++=(char)sizeof(Instruction);
  *h++=(char)sizeof(lua_Number);
- *h++=(char)(((lua_Number)0.5)==0);		/* is lua_Number integral? */
+
+ /* 
+  * Last byte of header (0/1 in unpatched Lua 5.1.3):
+  *
+  * 0: lua_Number is float/double/ldouble (nonpatched only)
+  * 1: lua_Number is integer (nonpatched only)
+  * 4: LNUM_INT32: sizeof(lua_Integer)
+  * 8: LNUM_INT64: sizeof(lua_Integer)
+  * +0x80: LNUM_COMPLEX
+  */
+ *h++ = (char)( sizeof(lua_Integer)
+#ifdef LNUM_COMPLEX
+    | 0x80
+#endif
+    );
 }
diff -urN --exclude=.svn --exclude=.DS_Store --exclude='*.orig' --exclude='*.o' /tmp/lua-5.1.4/src/lvm.c lua-5.1.4-patched/src/lvm.c
--- /tmp/lua-5.1.4/src/lvm.c	2007-12-28 17:32:23.000000000 +0200
+++ lua-5.1.4-patched/src/lvm.c	2009-04-17 15:36:20.000000000 +0300
@@ -25,22 +25,35 @@
 #include "ltable.h"
 #include "ltm.h"
 #include "lvm.h"
-
-
+#include "llex.h"
+#include "lnum.h"
 
 /* limit for table tag-method chains (to avoid loops) */
 #define MAXTAGLOOP	100
 
 
-const TValue *luaV_tonumber (const TValue *obj, TValue *n) {
-  lua_Number num;
+/*
+ * If 'obj' is a string, it is tried to be interpreted as a number.
+ */
+const TValue *luaV_tonumber ( const TValue *obj, TValue *n) {
+  lua_Number d;
+  lua_Integer i;
+  
   if (ttisnumber(obj)) return obj;
-  if (ttisstring(obj) && luaO_str2d(svalue(obj), &num)) {
-    setnvalue(n, num);
-    return n;
-  }
-  else
-    return NULL;
+
+  if (ttisstring(obj)) {
+    switch( luaO_str2d( svalue(obj), &d, &i ) ) {
+        case TK_INT:
+            setivalue(n,i); return n;
+        case TK_NUMBER: 
+            setnvalue(n,d); return n;
+#ifdef LNUM_COMPLEX
+        case TK_NUMBER2:    /* "N.NNNi", != 0 */
+            setnvalue_complex_fast(n, d*I); return n;
+#endif
+        }
+    }
+  return NULL;
 }
 
 
@@ -49,8 +62,7 @@
     return 0;
   else {
     char s[LUAI_MAXNUMBER2STR];
-    lua_Number n = nvalue(obj);
-    lua_number2str(s, n);
+    luaO_num2buf(s,obj);
     setsvalue2s(L, obj, luaS_new(L, s));
     return 1;
   }
@@ -218,59 +230,140 @@
 }
 
 
+#ifdef LNUM_COMPLEX
+void error_complex( lua_State *L, const TValue *l, const TValue *r )
+{
+  char buf1[ LUAI_MAXNUMBER2STR ];
+  char buf2[ LUAI_MAXNUMBER2STR ];
+  luaO_num2buf( buf1, l );
+  luaO_num2buf( buf2, r );
+  luaG_runerror( L, "unable to compare: %s with %s", buf1, buf2 );
+  /* no return */
+}
+#endif
+
+
 int luaV_lessthan (lua_State *L, const TValue *l, const TValue *r) {
   int res;
-  if (ttype(l) != ttype(r))
-    return luaG_ordererror(L, l, r);
-  else if (ttisnumber(l))
-    return luai_numlt(nvalue(l), nvalue(r));
-  else if (ttisstring(l))
-    return l_strcmp(rawtsvalue(l), rawtsvalue(r)) < 0;
-  else if ((res = call_orderTM(L, l, r, TM_LT)) != -1)
-    return res;
+  int tl= ttype(l);
+
+  if (tl == ttype(r)) {
+    switch(tl) {
+#ifdef LUA_TINT
+      case LUA_TINT:
+        return ivalue(l) < ivalue(r);
+#endif
+      case LUA_TNUMBER:   
+#ifdef LNUM_COMPLEX
+        if ( (nvalue_img_fast(l)!=0) || (nvalue_img_fast(r)!=0) )
+          error_complex( L, l, r );
+#endif
+        return luai_numlt(nvalue_fast(l), nvalue_fast(r));
+      case LUA_TSTRING:   
+        return l_strcmp(rawtsvalue(l), rawtsvalue(r)) < 0;
+    }
+    if ((res = call_orderTM(L, l, r, TM_LT)) != -1)
+      return res;
+    /* fall through to 'luaG_ordererror()' */
+  }
+#ifdef LUA_TINT
+  else if (ttype_ext(l) == ttype_ext(r)) {
+    lua_Integer tmp;
+      /* Avoid accuracy losing casts: if 'r' is integer by value, do comparisons
+       * in integer realm. Only otherwise cast 'l' to FP (which might change its
+       * value).
+       */
+# ifdef LNUM_COMPLEX
+    if ( (nvalue_img(l)!=0) || (nvalue_img(r)!=0) )
+      error_complex( L, l, r );
+# endif
+    if (tl==LUA_TINT) {  /* l:int, r:num */
+      return tt_integer_valued(r,&tmp) ? (ivalue(l) < tmp)
+                : luai_numlt( cast_num(ivalue(l)), nvalue_fast(r) );
+    } else {  /* l:num, r:int */
+      return tt_integer_valued(l,&tmp) ? (tmp < ivalue(r))
+                : luai_numlt( nvalue_fast(l), cast_num(ivalue(r)) );
+    }
+  }
+#endif
   return luaG_ordererror(L, l, r);
 }
 
 
 static int lessequal (lua_State *L, const TValue *l, const TValue *r) {
   int res;
-  if (ttype(l) != ttype(r))
-    return luaG_ordererror(L, l, r);
-  else if (ttisnumber(l))
-    return luai_numle(nvalue(l), nvalue(r));
-  else if (ttisstring(l))
-    return l_strcmp(rawtsvalue(l), rawtsvalue(r)) <= 0;
-  else if ((res = call_orderTM(L, l, r, TM_LE)) != -1)  /* first try `le' */
-    return res;
-  else if ((res = call_orderTM(L, r, l, TM_LT)) != -1)  /* else try `lt' */
-    return !res;
+  int tl= ttype(l);
+
+  if (tl == ttype(r)) {
+    switch(tl) {
+#ifdef LUA_TINT
+      case LUA_TINT:
+        return ivalue(l) <= ivalue(r);
+#endif
+      case LUA_TNUMBER:
+#ifdef LNUM_COMPLEX
+        if ( (nvalue_img_fast(l)!=0) || (nvalue_img_fast(r)!=0) )
+          error_complex( L, l, r );
+#endif
+        return luai_numle(nvalue_fast(l), nvalue_fast(r));
+      case LUA_TSTRING:
+        return l_strcmp(rawtsvalue(l), rawtsvalue(r)) <= 0;
+    }
+
+    if ((res = call_orderTM(L, l, r, TM_LE)) != -1)  /* first try `le' */
+      return res;
+    else if ((res = call_orderTM(L, r, l, TM_LT)) != -1)  /* else try `lt' */
+      return !res;
+    /* fall through to 'luaG_ordererror()' */
+  }
+#ifdef LUA_TINT
+  else if (ttype_ext(l) == ttype_ext(r)) {
+    lua_Integer tmp;
+# ifdef LNUM_COMPLEX
+    if ( (nvalue_img(l)!=0) || (nvalue_img(r)!=0) )
+      error_complex( L, l, r );
+# endif
+    if (tl==LUA_TINT) {  /* l:int, r:num */
+      return tt_integer_valued(r,&tmp) ? (ivalue(l) <= tmp)
+                : luai_numle( cast_num(ivalue(l)), nvalue_fast(r) );
+    } else {  /* l:num, r:int */
+      return tt_integer_valued(l,&tmp) ? (tmp <= ivalue(r))
+                : luai_numle( nvalue_fast(l), cast_num(ivalue(r)) );
+    }
+  }
+#endif
   return luaG_ordererror(L, l, r);
 }
 
 
-int luaV_equalval (lua_State *L, const TValue *t1, const TValue *t2) {
+/* Note: 'luaV_equalval()' and 'luaO_rawequalObj()' have largely overlapping
+ *       implementation.
+ */
+int luaV_equalval (lua_State *L, const TValue *l, const TValue *r) {
   const TValue *tm;
-  lua_assert(ttype(t1) == ttype(t2));
-  switch (ttype(t1)) {
+  lua_assert( ttype_ext(l) == ttype_ext(r) );
+  switch (ttype(l)) {
     case LUA_TNIL: return 1;
-    case LUA_TNUMBER: return luai_numeq(nvalue(t1), nvalue(t2));
-    case LUA_TBOOLEAN: return bvalue(t1) == bvalue(t2);  /* true must be 1 !! */
-    case LUA_TLIGHTUSERDATA: return pvalue(t1) == pvalue(t2);
+#ifdef LUA_TINT
+    case LUA_TINT:
+#endif
+    case LUA_TNUMBER: return luaO_rawequalObj(l,r);
+    case LUA_TBOOLEAN: return bvalue(l) == bvalue(r);  /* true must be 1 !! */
+    case LUA_TLIGHTUSERDATA: return pvalue(l) == pvalue(r);
     case LUA_TUSERDATA: {
-      if (uvalue(t1) == uvalue(t2)) return 1;
-      tm = get_compTM(L, uvalue(t1)->metatable, uvalue(t2)->metatable,
-                         TM_EQ);
+      if (uvalue(l) == uvalue(r)) return 1;
+      tm = get_compTM(L, uvalue(l)->metatable, uvalue(r)->metatable, TM_EQ);
       break;  /* will try TM */
     }
     case LUA_TTABLE: {
-      if (hvalue(t1) == hvalue(t2)) return 1;
-      tm = get_compTM(L, hvalue(t1)->metatable, hvalue(t2)->metatable, TM_EQ);
+      if (hvalue(l) == hvalue(r)) return 1;
+      tm = get_compTM(L, hvalue(l)->metatable, hvalue(r)->metatable, TM_EQ);
       break;  /* will try TM */
     }
-    default: return gcvalue(t1) == gcvalue(t2);
+    default: return gcvalue(l) == gcvalue(r);
   }
   if (tm == NULL) return 0;  /* no TM? */
-  callTMres(L, L->top, tm, t1, t2);  /* call TM */
+  callTMres(L, L->top, tm, l, r);  /* call TM */
   return !l_isfalse(L->top);
 }
 
@@ -310,30 +403,6 @@
 }
 
 
-static void Arith (lua_State *L, StkId ra, const TValue *rb,
-                   const TValue *rc, TMS op) {
-  TValue tempb, tempc;
-  const TValue *b, *c;
-  if ((b = luaV_tonumber(rb, &tempb)) != NULL &&
-      (c = luaV_tonumber(rc, &tempc)) != NULL) {
-    lua_Number nb = nvalue(b), nc = nvalue(c);
-    switch (op) {
-      case TM_ADD: setnvalue(ra, luai_numadd(nb, nc)); break;
-      case TM_SUB: setnvalue(ra, luai_numsub(nb, nc)); break;
-      case TM_MUL: setnvalue(ra, luai_nummul(nb, nc)); break;
-      case TM_DIV: setnvalue(ra, luai_numdiv(nb, nc)); break;
-      case TM_MOD: setnvalue(ra, luai_nummod(nb, nc)); break;
-      case TM_POW: setnvalue(ra, luai_numpow(nb, nc)); break;
-      case TM_UNM: setnvalue(ra, luai_numunm(nb)); break;
-      default: lua_assert(0); break;
-    }
-  }
-  else if (!call_binTM(L, rb, rc, ra, op))
-    luaG_aritherror(L, rb, rc);
-}
-
-
-
 /*
 ** some macros for common tasks in `luaV_execute'
 */
@@ -357,17 +426,177 @@
 #define Protect(x)	{ L->savedpc = pc; {x;}; base = L->base; }
 
 
-#define arith_op(op,tm) { \
-        TValue *rb = RKB(i); \
-        TValue *rc = RKC(i); \
-        if (ttisnumber(rb) && ttisnumber(rc)) { \
-          lua_Number nb = nvalue(rb), nc = nvalue(rc); \
-          setnvalue(ra, op(nb, nc)); \
-        } \
-        else \
-          Protect(Arith(L, ra, rb, rc, tm)); \
+/* Note: if called for unary operations, 'rc'=='rb'.
+ */
+static void Arith (lua_State *L, StkId ra, const TValue *rb,
+                   const TValue *rc, TMS op) {
+  TValue tempb, tempc;
+  const TValue *b, *c;
+  lua_Number nb,nc;
+
+  if ((b = luaV_tonumber(rb, &tempb)) != NULL &&
+      (c = luaV_tonumber(rc, &tempc)) != NULL) {
+
+    /* Keep integer arithmetics in the integer realm, if possible.
+     */
+#ifdef LUA_TINT
+    if (ttisint(b) && ttisint(c)) {
+      lua_Integer ib = ivalue(b), ic = ivalue(c);
+      lua_Integer *ri = &ra->value.i;
+      ra->tt= LUA_TINT;  /* part of 'setivalue(ra)' */
+      switch (op) {
+        case TM_ADD: if (try_addint( ri, ib, ic)) return; break;
+        case TM_SUB: if (try_subint( ri, ib, ic)) return; break;
+        case TM_MUL: if (try_mulint( ri, ib, ic)) return; break;
+        case TM_DIV: if (try_divint( ri, ib, ic)) return; break;
+        case TM_MOD: if (try_modint( ri, ib, ic)) return; break;
+        case TM_POW: if (try_powint( ri, ib, ic)) return; break;
+        case TM_UNM: if (try_unmint( ri, ib)) return; break;
+        default: lua_assert(0);
+      }
+    }
+#endif
+    /* Fallback to floating point, when leaving range. */
+
+#ifdef LNUM_COMPLEX
+    if ((nvalue_img(b)!=0) || (nvalue_img(c)!=0)) {
+      lua_Complex r;
+      if (op==TM_UNM) {
+        r= -nvalue_complex_fast(b);     /* never an integer (or scalar) */
+        setnvalue_complex_fast( ra, r );
+      } else {
+        lua_Complex bb= nvalue_complex(b), cc= nvalue_complex(c);
+        switch (op) {
+          case TM_ADD: r= bb + cc; break;
+          case TM_SUB: r= bb - cc; break;
+          case TM_MUL: r= bb * cc; break;
+          case TM_DIV: r= bb / cc; break;
+          case TM_MOD: 
+            luaG_runerror(L, "attempt to use %% on complex numbers");  /* no return */
+          case TM_POW: r= luai_vectpow( bb, cc ); break;
+          default: lua_assert(0); r=0;
+        }
+        setnvalue_complex( ra, r );
       }
+      return;
+    }
+#endif
+    nb = nvalue(b); nc = nvalue(c);
+    switch (op) {
+      case TM_ADD: setnvalue(ra, luai_numadd(nb, nc)); return;
+      case TM_SUB: setnvalue(ra, luai_numsub(nb, nc)); return;
+      case TM_MUL: setnvalue(ra, luai_nummul(nb, nc)); return;
+      case TM_DIV: setnvalue(ra, luai_numdiv(nb, nc)); return;
+      case TM_MOD: setnvalue(ra, luai_nummod(nb, nc)); return;
+      case TM_POW: setnvalue(ra, luai_numpow(nb, nc)); return;
+      case TM_UNM: setnvalue(ra, luai_numunm(nb)); return;
+      default: lua_assert(0);
+    }
+  }
+  
+  /* Either operand not a number */
+  if (!call_binTM(L, rb, rc, ra, op))
+    luaG_aritherror(L, rb, rc);
+}
 
+/* Helper macro to sort arithmetic operations into four categories:
+ *  TK_INT: integer - integer operands
+ *  TK_NUMBER: number - number (non complex, either may be integer)
+ *  TK_NUMBER2: complex numbers (at least the other)
+ *  0: non-numeric (at least the other)
+*/
+#ifdef LNUM_COMPLEX
+static inline int arith_mode( const TValue *rb, const TValue *rc ) {
+  if (ttisint(rb) && ttisint(rc)) return TK_INT;
+  if (ttiscomplex(rb) || ttiscomplex(rc)) return TK_NUMBER2;
+  if (ttisnumber(rb) && ttisnumber(rc)) return TK_NUMBER;
+  return 0;
+}
+static inline int arith_mode1( const TValue *rb ) {
+  return ttisint(rb) ? TK_INT :
+         ttiscomplex(rb) ? TK_NUMBER2 :
+         ttisnumber(rb) ? TK_NUMBER : 0;
+}
+#elif defined(LUA_TINT)
+# define arith_mode(rb,rc) \
+    ( (ttisint(rb) && ttisint(rc)) ? TK_INT : \
+      (ttisnumber(rb) && ttisnumber(rc)) ? TK_NUMBER : 0 )
+# define arith_mode1(rb) \
+    ( ttisint(rb) ? TK_INT : ttisnumber(rb) ? TK_NUMBER : 0 )
+#else
+# define arith_mode(rb,rc) ( (ttisnumber(rb) && ttisnumber(rc)) ? TK_NUMBER : 0 )
+# define arith_mode1(rb) ( ttisnumber(rb) ? TK_NUMBER : 0 )
+#endif
+
+/* arith_op macro for two operators:
+ * automatically chooses, which function (number, integer, complex) to use
+ */
+#ifdef LUA_TINT
+# define ARITH_OP2_START( op_num, op_int ) \
+  int failed= 0; \
+  switch( arith_mode(rb,rc) ) { \
+    case TK_INT: \
+      if (op_int ( &(ra)->value.i, ivalue(rb), ivalue(rc) )) \
+        { ra->tt= LUA_TINT; break; } /* else flow through */ \
+    case TK_NUMBER: \
+      setnvalue(ra, op_num ( nvalue(rb), nvalue(rc) )); break;
+#else
+# define ARITH_OP2_START( op_num, _ ) \
+  int failed= 0; \
+  switch( arith_mode(rb,rc) ) { \
+    case TK_NUMBER: \
+      setnvalue(ra, op_num ( nvalue(rb), nvalue(rc) )); break;
+#endif
+
+#define ARITH_OP_END \
+    default: \
+      failed= 1; break; \
+  } if (!failed) continue;
+
+#define arith_op_continue_scalar( op_num, op_int ) \
+    ARITH_OP2_START( op_num, op_int ) \
+    ARITH_OP_END
+
+#ifdef LNUM_COMPLEX
+# define arith_op_continue( op_num, op_int, op_complex ) \
+    ARITH_OP2_START( op_num, op_int ) \
+      case TK_NUMBER2: \
+        setnvalue_complex( ra, op_complex ( nvalue_complex(rb), nvalue_complex(rc) ) ); break; \
+    ARITH_OP_END
+#else
+# define arith_op_continue(op_num,op_int,_) arith_op_continue_scalar(op_num,op_int)
+#endif
+
+/* arith_op macro for one operator:
+ */
+#ifdef LUA_TINT
+# define ARITH_OP1_START( op_num, op_int ) \
+  int failed= 0; \
+  switch( arith_mode1(rb) ) { \
+    case TK_INT: \
+      if (op_int ( &(ra)->value.i, ivalue(rb) )) \
+        { ra->tt= LUA_TINT; break; } /* else flow through */ \
+    case TK_NUMBER: \
+      setnvalue(ra, op_num (nvalue(rb))); break;
+#else
+# define ARITH_OP1_START( op_num, _ ) \
+  int failed= 0; \
+  switch( arith_mode1(rb) ) { \
+    case TK_NUMBER: \
+      setnvalue(ra, op_num (nvalue(rb))); break;
+#endif
+
+#ifdef LNUM_COMPLEX
+# define arith_op1_continue( op_num, op_int, op_complex ) \
+    ARITH_OP1_START( op_num, op_int ) \
+      case TK_NUMBER2: \
+        setnvalue_complex( ra, op_complex ( nvalue_complex_fast(rb) )); break; \
+    ARITH_OP_END
+#else
+# define arith_op1_continue( op_num, op_int, _ ) \
+    ARITH_OP1_START( op_num, op_int ) \
+    ARITH_OP_END
+#endif
 
 
 void luaV_execute (lua_State *L, int nexeccalls) {
@@ -468,38 +697,45 @@
         continue;
       }
       case OP_ADD: {
-        arith_op(luai_numadd, TM_ADD);
+        TValue *rb = RKB(i), *rc= RKC(i);
+        arith_op_continue( luai_numadd, try_addint, luai_vectadd );
+        Protect(Arith(L, ra, rb, rc, TM_ADD)); \
         continue;
       }
       case OP_SUB: {
-        arith_op(luai_numsub, TM_SUB);
+        TValue *rb = RKB(i), *rc= RKC(i);
+        arith_op_continue( luai_numsub, try_subint, luai_vectsub );
+        Protect(Arith(L, ra, rb, rc, TM_SUB));
         continue;
       }
       case OP_MUL: {
-        arith_op(luai_nummul, TM_MUL);
+        TValue *rb = RKB(i), *rc= RKC(i);
+        arith_op_continue(luai_nummul, try_mulint, luai_vectmul);
+        Protect(Arith(L, ra, rb, rc, TM_MUL));
         continue;
       }
       case OP_DIV: {
-        arith_op(luai_numdiv, TM_DIV);
+        TValue *rb = RKB(i), *rc= RKC(i);
+        arith_op_continue(luai_numdiv, try_divint, luai_vectdiv);
+        Protect(Arith(L, ra, rb, rc, TM_DIV));
         continue;
       }
       case OP_MOD: {
-        arith_op(luai_nummod, TM_MOD);
+        TValue *rb = RKB(i), *rc= RKC(i);
+        arith_op_continue_scalar(luai_nummod, try_modint);  /* scalars only */
+        Protect(Arith(L, ra, rb, rc, TM_MOD));
         continue;
       }
       case OP_POW: {
-        arith_op(luai_numpow, TM_POW);
+        TValue *rb = RKB(i), *rc= RKC(i);
+        arith_op_continue(luai_numpow, try_powint, luai_vectpow);
+        Protect(Arith(L, ra, rb, rc, TM_POW));
         continue;
       }
       case OP_UNM: {
         TValue *rb = RB(i);
-        if (ttisnumber(rb)) {
-          lua_Number nb = nvalue(rb);
-          setnvalue(ra, luai_numunm(nb));
-        }
-        else {
-          Protect(Arith(L, ra, rb, rb, TM_UNM));
-        }
+        arith_op1_continue(luai_numunm, try_unmint, luai_vectunm);
+        Protect(Arith(L, ra, rb, rb, TM_UNM));
         continue;
       }
       case OP_NOT: {
@@ -511,11 +747,11 @@
         const TValue *rb = RB(i);
         switch (ttype(rb)) {
           case LUA_TTABLE: {
-            setnvalue(ra, cast_num(luaH_getn(hvalue(rb))));
+            setivalue(ra, luaH_getn(hvalue(rb)));
             break;
           }
           case LUA_TSTRING: {
-            setnvalue(ra, cast_num(tsvalue(rb)->len));
+            setivalue(ra, tsvalue(rb)->len);
             break;
           }
           default: {  /* try metamethod */
@@ -648,14 +884,33 @@
         }
       }
       case OP_FORLOOP: {
-        lua_Number step = nvalue(ra+2);
-        lua_Number idx = luai_numadd(nvalue(ra), step); /* increment index */
-        lua_Number limit = nvalue(ra+1);
-        if (luai_numlt(0, step) ? luai_numle(idx, limit)
-                                : luai_numle(limit, idx)) {
-          dojump(L, pc, GETARG_sBx(i));  /* jump back */
-          setnvalue(ra, idx);  /* update internal index... */
-          setnvalue(ra+3, idx);  /* ...and external index */
+        /* If start,step and limit are all integers, we don't need to check
+         * against overflow in the looping.
+         */
+#ifdef LUA_TINT
+        if (ttisint(ra) && ttisint(ra+1) && ttisint(ra+2)) {
+          lua_Integer step = ivalue(ra+2);
+          lua_Integer idx = ivalue(ra) + step; /* increment index */
+          lua_Integer limit = ivalue(ra+1);
+          if (step > 0 ? (idx <= limit) : (limit <= idx)) {
+            dojump(L, pc, GETARG_sBx(i));  /* jump back */
+            setivalue(ra, idx);  /* update internal index... */
+            setivalue(ra+3, idx);  /* ...and external index */
+          }
+        } else
+#endif
+        {
+          /* non-integer looping (don't use 'nvalue_fast', some may be integer!) 
+          */
+          lua_Number step = nvalue(ra+2);
+          lua_Number idx = luai_numadd(nvalue(ra), step); /* increment index */
+          lua_Number limit = nvalue(ra+1);
+          if (luai_numlt(0, step) ? luai_numle(idx, limit)
+                                  : luai_numle(limit, idx)) {
+            dojump(L, pc, GETARG_sBx(i));  /* jump back */
+            setnvalue(ra, idx);  /* update internal index... */
+            setnvalue(ra+3, idx);  /* ...and external index */
+          }
         }
         continue;
       }
@@ -664,12 +919,24 @@
         const TValue *plimit = ra+1;
         const TValue *pstep = ra+2;
         L->savedpc = pc;  /* next steps may throw errors */
+        /* Using same location for tonumber's both arguments, effectively does
+         * in-place modification (string->number). */
         if (!tonumber(init, ra))
           luaG_runerror(L, LUA_QL("for") " initial value must be a number");
         else if (!tonumber(plimit, ra+1))
           luaG_runerror(L, LUA_QL("for") " limit must be a number");
         else if (!tonumber(pstep, ra+2))
           luaG_runerror(L, LUA_QL("for") " step must be a number");
+        /* Step back one value (keep within integers if we can)
+         */
+#ifdef LUA_TINT
+        if (ttisint(ra) && ttisint(pstep) &&
+            try_subint( &ra->value.i, ivalue(ra), ivalue(pstep) )) {
+          dojump(L, pc, GETARG_sBx(i));
+          continue;
+        }
+        /* fallback to floating point */
+#endif
         setnvalue(ra, luai_numsub(nvalue(ra), nvalue(pstep)));
         dojump(L, pc, GETARG_sBx(i));
         continue;
@@ -707,7 +974,7 @@
           luaH_resizearray(L, h, last);  /* pre-alloc it at once */
         for (; n > 0; n--) {
           TValue *val = ra+n;
-          setobj2t(L, luaH_setnum(L, h, last--), val);
+          setobj2t(L, luaH_setint(L, h, last--), val);
           luaC_barriert(L, h, val);
         }
         continue;
diff -urN --exclude=.svn --exclude=.DS_Store --exclude='*.orig' --exclude='*.o' /tmp/lua-5.1.4/src/lvm.h lua-5.1.4-patched/src/lvm.h
--- /tmp/lua-5.1.4/src/lvm.h	2007-12-27 15:02:25.000000000 +0200
+++ lua-5.1.4-patched/src/lvm.h	2009-03-26 21:21:04.000000000 +0200
@@ -15,11 +15,9 @@
 
 #define tostring(L,o) ((ttype(o) == LUA_TSTRING) || (luaV_tostring(L, o)))
 
-#define tonumber(o,n)	(ttype(o) == LUA_TNUMBER || \
-                         (((o) = luaV_tonumber(o,n)) != NULL))
+#define tonumber(o,n) (ttisnumber(o) || (((o) = luaV_tonumber(o,n)) != NULL))
 
-#define equalobj(L,o1,o2) \
-	(ttype(o1) == ttype(o2) && luaV_equalval(L, o1, o2))
+#define equalobj(L,o1,o2) ((ttype_ext(o1)==ttype_ext(o2)) && luaV_equalval(L, o1, o2))
 
 
 LUAI_FUNC int luaV_lessthan (lua_State *L, const TValue *l, const TValue *r);
diff -urN --exclude=.svn --exclude=.DS_Store --exclude='*.orig' --exclude='*.o' /tmp/lua-5.1.4/src/print.c lua-5.1.4-patched/src/print.c
--- /tmp/lua-5.1.4/src/print.c	2007-03-26 03:17:38.000000000 +0300
+++ lua-5.1.4-patched/src/print.c	2009-03-26 21:21:04.000000000 +0200
@@ -14,6 +14,7 @@
 #include "lobject.h"
 #include "lopcodes.h"
 #include "lundump.h"
+#include "lnum.h"
 
 #define PrintFunction	luaU_print
 
@@ -59,8 +60,17 @@
   case LUA_TBOOLEAN:
 	printf(bvalue(o) ? "true" : "false");
 	break;
+#ifdef LUA_TINT
+  case LUA_TINT:
+	printf(LUA_INTEGER_FMT,ivalue(o));
+	break;
+#endif
   case LUA_TNUMBER:
-	printf(LUA_NUMBER_FMT,nvalue(o));
+#ifdef LNUM_COMPLEX
+    { lua_Number b= nvalue_img_fast(o);    /* TBD: Do we get complex values here? */
+	  printf( LUA_NUMBER_FMT "%s" LUA_NUMBER_FMT "i", nvalue_fast(o), b>=0 ? "+":"", b ); }
+#endif
+	printf(LUA_NUMBER_FMT,nvalue_fast(o));
 	break;
   case LUA_TSTRING:
 	PrintString(rawtsvalue(o));
